/* automatically generated by rust-bindgen 0.69.4 */

/* libR-sys version: 0.7.0 */
/* bindgen clang version: Homebrew clang version 18.1.8 */
/* r version: 4.4.1 */

#[doc = "R_xlen_t is defined as int on 32-bit platforms, and\n that confuses Rust. Keeping it always as ptrdiff_t works\n fine even on 32-bit.\n <div rustbindgen replaces=\"R_xlen_t\"></div>"]
pub type R_xlen_t = isize;
pub type L_fp = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut f64,
        arg2: *mut f64,
        arg3: *mut f64,
    ) -> *mut ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = "The LAPACK version: might change after installation with\nexternal LAPACK.\n\nIn the LAPACK sources in the INSTALL directory."]
    pub fn ilaver_(
        major: *mut ::std::os::raw::c_int,
        minor: *mut ::std::os::raw::c_int,
        patch: *mut ::std::os::raw::c_int,
    );
    #[doc = "DBDSQR - compute the singular value decomposition (SVD) of a real */\n/* N-by-N (upper or lower) bidiagonal matrix B"]
    pub fn dbdsqr_(
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        ncvt: *const ::std::os::raw::c_int,
        nru: *const ::std::os::raw::c_int,
        ncc: *const ::std::os::raw::c_int,
        d: *mut f64,
        e: *mut f64,
        vt: *mut f64,
        ldvt: *const ::std::os::raw::c_int,
        u: *mut f64,
        ldu: *const ::std::os::raw::c_int,
        c: *mut f64,
        ldc: *const ::std::os::raw::c_int,
        work: *mut f64,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    #[doc = "DDISNA - compute the reciprocal condition numbers for the */\n/* eigenvectors of a real symmetric or complex Hermitian matrix or */\n/* for the left or right singular vectors of a general m-by-n */\n/* matrix"]
    pub fn ddisna_(
        job: *const ::std::os::raw::c_char,
        m: *const ::std::os::raw::c_int,
        n: *const ::std::os::raw::c_int,
        d: *mut f64,
        sep: *mut f64,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    #[doc = "DGBBRD - reduce a real general m-by-n band matrix A to upper */\n/* bidiagonal form B by an orthogonal transformation"]
    pub fn dgbbrd_(
        vect: *const ::std::os::raw::c_char,
        m: *const ::std::os::raw::c_int,
        n: *const ::std::os::raw::c_int,
        ncc: *const ::std::os::raw::c_int,
        kl: *const ::std::os::raw::c_int,
        ku: *const ::std::os::raw::c_int,
        ab: *mut f64,
        ldab: *const ::std::os::raw::c_int,
        d: *mut f64,
        e: *mut f64,
        q: *mut f64,
        ldq: *const ::std::os::raw::c_int,
        pt: *mut f64,
        ldpt: *const ::std::os::raw::c_int,
        c: *mut f64,
        ldc: *const ::std::os::raw::c_int,
        work: *mut f64,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    #[doc = "DGBCON - estimate the reciprocal of the condition number of a */\n/* real general band matrix A, in either the 1-norm or the */\n/* infinity-norm"]
    pub fn dgbcon_(
        norm: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        kl: *const ::std::os::raw::c_int,
        ku: *const ::std::os::raw::c_int,
        ab: *mut f64,
        ldab: *const ::std::os::raw::c_int,
        ipiv: *mut ::std::os::raw::c_int,
        anorm: *const f64,
        rcond: *mut f64,
        work: *mut f64,
        iwork: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    #[doc = "DGBEQU - compute row and column scalings intended to equilibrate */\n/* an M-by-N band matrix A and reduce its condition number"]
    pub fn dgbequ_(
        m: *const ::std::os::raw::c_int,
        n: *const ::std::os::raw::c_int,
        kl: *const ::std::os::raw::c_int,
        ku: *const ::std::os::raw::c_int,
        ab: *mut f64,
        ldab: *const ::std::os::raw::c_int,
        r: *mut f64,
        c: *mut f64,
        rowcnd: *mut f64,
        colcnd: *mut f64,
        amax: *mut f64,
        info: *mut ::std::os::raw::c_int,
    );
    #[doc = "DGBRFS - improve the computed solution to a system of linear */\n/* equations when the coefficient matrix is banded, and provides */\n/* error bounds and backward error estimates for the solution"]
    pub fn dgbrfs_(
        trans: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        kl: *const ::std::os::raw::c_int,
        ku: *const ::std::os::raw::c_int,
        nrhs: *const ::std::os::raw::c_int,
        ab: *mut f64,
        ldab: *const ::std::os::raw::c_int,
        afb: *mut f64,
        ldafb: *const ::std::os::raw::c_int,
        ipiv: *mut ::std::os::raw::c_int,
        b: *mut f64,
        ldb: *const ::std::os::raw::c_int,
        x: *mut f64,
        ldx: *const ::std::os::raw::c_int,
        ferr: *mut f64,
        berr: *mut f64,
        work: *mut f64,
        iwork: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    #[doc = "DGBSV - compute the solution to a real system of linear */\n/* equations A * X = B, where A is a band matrix of order N with */\n/* KL subdiagonals and KU superdiagonals, and X and B are */\n/* N-by-NRHS matrices"]
    pub fn dgbsv_(
        n: *const ::std::os::raw::c_int,
        kl: *const ::std::os::raw::c_int,
        ku: *const ::std::os::raw::c_int,
        nrhs: *const ::std::os::raw::c_int,
        ab: *mut f64,
        ldab: *const ::std::os::raw::c_int,
        ipiv: *mut ::std::os::raw::c_int,
        b: *mut f64,
        ldb: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    );
    #[doc = "DGBSVX - use the LU factorization to compute the solution to a */\n/* real system of linear equations A * X = B or A**T * X = B"]
    pub fn dgbsvx_(
        fact: *const ::std::os::raw::c_int,
        trans: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        kl: *const ::std::os::raw::c_int,
        ku: *const ::std::os::raw::c_int,
        nrhs: *const ::std::os::raw::c_int,
        ab: *mut f64,
        ldab: *const ::std::os::raw::c_int,
        afb: *mut f64,
        ldafb: *const ::std::os::raw::c_int,
        ipiv: *mut ::std::os::raw::c_int,
        equed: *const ::std::os::raw::c_char,
        r: *mut f64,
        c: *mut f64,
        b: *mut f64,
        ldb: *const ::std::os::raw::c_int,
        x: *mut f64,
        ldx: *const ::std::os::raw::c_int,
        rcond: *mut f64,
        ferr: *mut f64,
        berr: *mut f64,
        work: *mut f64,
        iwork: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
    );
    #[doc = "DGBTF2 - compute an LU factorization of a real m-by-n band */\n/* matrix A using partial pivoting with row La_INT *erchanges"]
    pub fn dgbtf2_(
        m: *const ::std::os::raw::c_int,
        n: *const ::std::os::raw::c_int,
        kl: *const ::std::os::raw::c_int,
        ku: *const ::std::os::raw::c_int,
        ab: *mut f64,
        ldab: *const ::std::os::raw::c_int,
        ipiv: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    );
    #[doc = "DGBTRF - compute an LU factorization of a real m-by-n band */\n/* matrix A using partial pivoting with row La_INT *erchanges"]
    pub fn dgbtrf_(
        m: *const ::std::os::raw::c_int,
        n: *const ::std::os::raw::c_int,
        kl: *const ::std::os::raw::c_int,
        ku: *const ::std::os::raw::c_int,
        ab: *mut f64,
        ldab: *const ::std::os::raw::c_int,
        ipiv: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    );
    #[doc = "DGBTRS - solve a system of linear equations\tA * X = B or  */\n/* A' * X = B with a general band matrix A using the LU */\n/* factorization computed by DGBTRF"]
    pub fn dgbtrs_(
        trans: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        kl: *const ::std::os::raw::c_int,
        ku: *const ::std::os::raw::c_int,
        nrhs: *const ::std::os::raw::c_int,
        ab: *const f64,
        ldab: *const ::std::os::raw::c_int,
        ipiv: *const ::std::os::raw::c_int,
        b: *mut f64,
        ldb: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    #[doc = "DGEBAK - form the right or left eigenvectors of a real general */\n/* matrix by backward transformation on the computed eigenvectors */\n/* of the balanced matrix output by DGEBAL"]
    pub fn dgebak_(
        job: *const ::std::os::raw::c_char,
        side: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        ilo: *const ::std::os::raw::c_int,
        ihi: *const ::std::os::raw::c_int,
        scale: *mut f64,
        m: *const ::std::os::raw::c_int,
        v: *mut f64,
        ldv: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
    );
    #[doc = "DGEBAL - balance a general real matrix A"]
    pub fn dgebal_(
        job: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        a: *mut f64,
        lda: *const ::std::os::raw::c_int,
        ilo: *mut ::std::os::raw::c_int,
        ihi: *mut ::std::os::raw::c_int,
        scale: *mut f64,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    #[doc = "DGEBD2 - reduce a real general m by n matrix A to upper or */\n/* lower bidiagonal form B by an orthogonal transformation"]
    pub fn dgebd2_(
        m: *const ::std::os::raw::c_int,
        n: *const ::std::os::raw::c_int,
        a: *mut f64,
        lda: *const ::std::os::raw::c_int,
        d: *mut f64,
        e: *mut f64,
        tauq: *mut f64,
        taup: *mut f64,
        work: *mut f64,
        info: *mut ::std::os::raw::c_int,
    );
    #[doc = "DGEBRD - reduce a general real M-by-N matrix A to upper or */\n/* lower bidiagonal form B by an orthogonal transformation"]
    pub fn dgebrd_(
        m: *const ::std::os::raw::c_int,
        n: *const ::std::os::raw::c_int,
        a: *mut f64,
        lda: *const ::std::os::raw::c_int,
        d: *mut f64,
        e: *mut f64,
        tauq: *mut f64,
        taup: *mut f64,
        work: *mut f64,
        lwork: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    );
    #[doc = "DGECON - estimate the reciprocal of the condition number of a */\n/* general real matrix A, in either the 1-norm or the */\n/* infinity-norm, using the LU factorization computed by DGETRF"]
    pub fn dgecon_(
        norm: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        a: *const f64,
        lda: *const ::std::os::raw::c_int,
        anorm: *const f64,
        rcond: *mut f64,
        work: *mut f64,
        iwork: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    #[doc = "DGEEQU - compute row and column scalings La_INT *ended to equilibrate */\n/* an M-by-N matrix A and reduce its condition number"]
    pub fn dgeequ_(
        m: *const ::std::os::raw::c_int,
        n: *const ::std::os::raw::c_int,
        a: *mut f64,
        lda: *const ::std::os::raw::c_int,
        r: *mut f64,
        c: *mut f64,
        rowcnd: *mut f64,
        colcnd: *mut f64,
        amax: *mut f64,
        info: *mut ::std::os::raw::c_int,
    );
    #[doc = "DGEES - compute for an N-by-N real nonsymmetric matrix A, the */\n/* eigenvalues, the real Schur form T, and, optionally, the matrix */\n/* of Schur vectors Z"]
    pub fn dgees_(
        jobvs: *const ::std::os::raw::c_char,
        sort: *const ::std::os::raw::c_char,
        select: ::std::option::Option<
            unsafe extern "C" fn(arg1: *const f64, arg2: *const f64) -> ::std::os::raw::c_int,
        >,
        n: *const ::std::os::raw::c_int,
        a: *mut f64,
        lda: *const ::std::os::raw::c_int,
        sdim: *mut ::std::os::raw::c_int,
        wr: *mut f64,
        wi: *mut f64,
        vs: *mut f64,
        ldvs: *const ::std::os::raw::c_int,
        work: *mut f64,
        lwork: *const ::std::os::raw::c_int,
        bwork: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
    );
    #[doc = "DGEESX - compute for an N-by-N real nonsymmetric matrix A, the */\n/* eigenvalues, the real Schur form T, and, optionally, the matrix */\n/* of Schur vectors Z"]
    pub fn dgeesx_(
        jobvs: *const ::std::os::raw::c_char,
        sort: *const ::std::os::raw::c_char,
        select: ::std::option::Option<
            unsafe extern "C" fn(arg1: *const f64, arg2: *const f64) -> ::std::os::raw::c_int,
        >,
        sense: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        a: *mut f64,
        lda: *const ::std::os::raw::c_int,
        sdim: *mut ::std::os::raw::c_int,
        wr: *mut f64,
        wi: *mut f64,
        vs: *mut f64,
        ldvs: *const ::std::os::raw::c_int,
        rconde: *mut f64,
        rcondv: *mut f64,
        work: *mut f64,
        lwork: *const ::std::os::raw::c_int,
        iwork: *mut ::std::os::raw::c_int,
        liwork: *const ::std::os::raw::c_int,
        bwork: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
        arg3: usize,
    );
    #[doc = "DGEEV - compute for an N-by-N real nonsymmetric matrix A, the */\n/* eigenvalues and, optionally, the left and/or right eigenvectors"]
    pub fn dgeev_(
        jobvl: *const ::std::os::raw::c_char,
        jobvr: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        a: *mut f64,
        lda: *const ::std::os::raw::c_int,
        wr: *mut f64,
        wi: *mut f64,
        vl: *mut f64,
        ldvl: *const ::std::os::raw::c_int,
        vr: *mut f64,
        ldvr: *const ::std::os::raw::c_int,
        work: *mut f64,
        lwork: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
    );
    #[doc = "DGEEVX - compute for an N-by-N real nonsymmetric matrix A, the */\n/* eigenvalues and, optionally, the left and/or right eigenvectors"]
    pub fn dgeevx_(
        balanc: *const ::std::os::raw::c_char,
        jobvl: *const ::std::os::raw::c_char,
        jobvr: *const ::std::os::raw::c_char,
        sense: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        a: *mut f64,
        lda: *const ::std::os::raw::c_int,
        wr: *mut f64,
        wi: *mut f64,
        vl: *mut f64,
        ldvl: *const ::std::os::raw::c_int,
        vr: *mut f64,
        ldvr: *const ::std::os::raw::c_int,
        ilo: *mut ::std::os::raw::c_int,
        ihi: *mut ::std::os::raw::c_int,
        scale: *mut f64,
        abnrm: *mut f64,
        rconde: *mut f64,
        rcondv: *mut f64,
        work: *mut f64,
        lwork: *const ::std::os::raw::c_int,
        iwork: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
        arg3: usize,
        arg4: usize,
    );
    #[doc = "DGEHD2 - reduce a real general matrix A to upper Hessenberg */\n/* form H by an orthogonal similarity transformation"]
    pub fn dgehd2_(
        n: *const ::std::os::raw::c_int,
        ilo: *const ::std::os::raw::c_int,
        ihi: *const ::std::os::raw::c_int,
        a: *mut f64,
        lda: *const ::std::os::raw::c_int,
        tau: *mut f64,
        work: *mut f64,
        info: *mut ::std::os::raw::c_int,
    );
    #[doc = "DGEHRD - reduce a real general matrix A to upper Hessenberg */\n/* form H by an orthogonal similarity transformation"]
    pub fn dgehrd_(
        n: *const ::std::os::raw::c_int,
        ilo: *const ::std::os::raw::c_int,
        ihi: *const ::std::os::raw::c_int,
        a: *mut f64,
        lda: *const ::std::os::raw::c_int,
        tau: *mut f64,
        work: *mut f64,
        lwork: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    );
    #[doc = "DGELQ2 - compute an LQ factorization of a real m by n matrix A"]
    pub fn dgelq2_(
        m: *const ::std::os::raw::c_int,
        n: *const ::std::os::raw::c_int,
        a: *mut f64,
        lda: *const ::std::os::raw::c_int,
        tau: *mut f64,
        work: *mut f64,
        info: *mut ::std::os::raw::c_int,
    );
    #[doc = "DGELQF - compute an LQ factorization of a real M-by-N matrix A"]
    pub fn dgelqf_(
        m: *const ::std::os::raw::c_int,
        n: *const ::std::os::raw::c_int,
        a: *mut f64,
        lda: *const ::std::os::raw::c_int,
        tau: *mut f64,
        work: *mut f64,
        lwork: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    );
    #[doc = "DGELS - solve overdetermined or underdetermined real linear */\n/* systems involving an M-by-N matrix A, or its transpose, using a */\n/* QR or LQ factorization of A"]
    pub fn dgels_(
        trans: *const ::std::os::raw::c_char,
        m: *const ::std::os::raw::c_int,
        n: *const ::std::os::raw::c_int,
        nrhs: *const ::std::os::raw::c_int,
        a: *mut f64,
        lda: *const ::std::os::raw::c_int,
        b: *mut f64,
        ldb: *const ::std::os::raw::c_int,
        work: *mut f64,
        lwork: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    #[doc = "DGELSS - compute the minimum norm solution to a real linear */\n/* least squares problem"]
    pub fn dgelss_(
        m: *const ::std::os::raw::c_int,
        n: *const ::std::os::raw::c_int,
        nrhs: *const ::std::os::raw::c_int,
        a: *mut f64,
        lda: *const ::std::os::raw::c_int,
        b: *mut f64,
        ldb: *const ::std::os::raw::c_int,
        s: *mut f64,
        rcond: *mut f64,
        rank: *mut ::std::os::raw::c_int,
        work: *mut f64,
        lwork: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    );
    #[doc = "DGELSY - compute the minimum-norm solution to a real linear */\n/* least squares problem"]
    pub fn dgelsy_(
        m: *const ::std::os::raw::c_int,
        n: *const ::std::os::raw::c_int,
        nrhs: *const ::std::os::raw::c_int,
        a: *mut f64,
        lda: *const ::std::os::raw::c_int,
        b: *mut f64,
        ldb: *const ::std::os::raw::c_int,
        jpvt: *mut ::std::os::raw::c_int,
        rcond: *const f64,
        rank: *mut ::std::os::raw::c_int,
        work: *mut f64,
        lwork: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    );
    #[doc = "DGEQL2 - compute a QL factorization of a real m by n matrix A"]
    pub fn dgeql2_(
        m: *const ::std::os::raw::c_int,
        n: *const ::std::os::raw::c_int,
        a: *mut f64,
        lda: *const ::std::os::raw::c_int,
        tau: *mut f64,
        work: *mut f64,
        info: *mut ::std::os::raw::c_int,
    );
    #[doc = "DGEQLF - compute a QL factorization of a real M-by-N matrix A"]
    pub fn dgeqlf_(
        m: *const ::std::os::raw::c_int,
        n: *const ::std::os::raw::c_int,
        a: *mut f64,
        lda: *const ::std::os::raw::c_int,
        tau: *mut f64,
        work: *mut f64,
        lwork: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    );
    #[doc = "DGEQP3 - compute a QR factorization with column pivoting of a */\n/* real M-by-N matrix A using level 3 BLAS"]
    pub fn dgeqp3_(
        m: *const ::std::os::raw::c_int,
        n: *const ::std::os::raw::c_int,
        a: *mut f64,
        lda: *const ::std::os::raw::c_int,
        jpvt: *mut ::std::os::raw::c_int,
        tau: *mut f64,
        work: *mut f64,
        lwork: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    );
    #[doc = "DGEQR2 - compute a QR factorization of a real m by n matrix A"]
    pub fn dgeqr2_(
        m: *const ::std::os::raw::c_int,
        n: *const ::std::os::raw::c_int,
        a: *mut f64,
        lda: *const ::std::os::raw::c_int,
        tau: *mut f64,
        work: *mut f64,
        info: *mut ::std::os::raw::c_int,
    );
    #[doc = "DGEQRF - compute a QR factorization of a real M-by-N matrix A"]
    pub fn dgeqrf_(
        m: *const ::std::os::raw::c_int,
        n: *const ::std::os::raw::c_int,
        a: *mut f64,
        lda: *const ::std::os::raw::c_int,
        tau: *mut f64,
        work: *mut f64,
        lwork: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    );
    #[doc = "DGERFS - improve the computed solution to a system of linear */\n/* equations and provides error bounds and backward error */\n/* estimates for the solution"]
    pub fn dgerfs_(
        trans: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        nrhs: *const ::std::os::raw::c_int,
        a: *mut f64,
        lda: *const ::std::os::raw::c_int,
        af: *mut f64,
        ldaf: *const ::std::os::raw::c_int,
        ipiv: *mut ::std::os::raw::c_int,
        b: *mut f64,
        ldb: *const ::std::os::raw::c_int,
        x: *mut f64,
        ldx: *const ::std::os::raw::c_int,
        ferr: *mut f64,
        berr: *mut f64,
        work: *mut f64,
        iwork: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    #[doc = "DGERQ2 - compute an RQ factorization of a real m by n matrix A"]
    pub fn dgerq2_(
        m: *const ::std::os::raw::c_int,
        n: *const ::std::os::raw::c_int,
        a: *mut f64,
        lda: *const ::std::os::raw::c_int,
        tau: *mut f64,
        work: *mut f64,
        info: *mut ::std::os::raw::c_int,
    );
    #[doc = "DGERQF - compute an RQ factorization of a real M-by-N matrix A"]
    pub fn dgerqf_(
        m: *const ::std::os::raw::c_int,
        n: *const ::std::os::raw::c_int,
        a: *mut f64,
        lda: *const ::std::os::raw::c_int,
        tau: *mut f64,
        work: *mut f64,
        lwork: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    );
    #[doc = "DGESV - compute the solution to a real system of linear */\n/* equations  A * X = B,"]
    pub fn dgesv_(
        n: *const ::std::os::raw::c_int,
        nrhs: *const ::std::os::raw::c_int,
        a: *mut f64,
        lda: *const ::std::os::raw::c_int,
        ipiv: *mut ::std::os::raw::c_int,
        b: *mut f64,
        ldb: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    );
    #[doc = "DGESVD - compute the singular value decomposition (SVD); of a */\n/* real M-by-N matrix A, optionally computing the left and/or */\n/* right singular vectors"]
    pub fn dgesvd_(
        jobu: *const ::std::os::raw::c_char,
        jobvt: *const ::std::os::raw::c_char,
        m: *const ::std::os::raw::c_int,
        n: *const ::std::os::raw::c_int,
        a: *mut f64,
        lda: *const ::std::os::raw::c_int,
        s: *mut f64,
        u: *mut f64,
        ldu: *const ::std::os::raw::c_int,
        vt: *mut f64,
        ldvt: *const ::std::os::raw::c_int,
        work: *mut f64,
        lwork: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
    );
    #[doc = "DGESVX - use the LU factorization to compute the solution to a */\n/* real system of linear equations  A * X = B,"]
    pub fn dgesvx_(
        fact: *const ::std::os::raw::c_char,
        trans: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        nrhs: *const ::std::os::raw::c_int,
        a: *mut f64,
        lda: *const ::std::os::raw::c_int,
        af: *mut f64,
        ldaf: *const ::std::os::raw::c_int,
        ipiv: *mut ::std::os::raw::c_int,
        equed: *mut ::std::os::raw::c_char,
        r: *mut f64,
        c: *mut f64,
        b: *mut f64,
        ldb: *const ::std::os::raw::c_int,
        x: *mut f64,
        ldx: *const ::std::os::raw::c_int,
        rcond: *mut f64,
        ferr: *mut f64,
        berr: *mut f64,
        work: *mut f64,
        iwork: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
        arg3: usize,
    );
    #[doc = "DGETF2 - compute an LU factorization of a general m-by-n */\n/* matrix A using partial pivoting with row La_INT *erchanges"]
    pub fn dgetf2_(
        m: *const ::std::os::raw::c_int,
        n: *const ::std::os::raw::c_int,
        a: *mut f64,
        lda: *const ::std::os::raw::c_int,
        ipiv: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    );
    #[doc = "DGETRF - compute an LU factorization of a general M-by-N */\n/* matrix A using partial pivoting with row La_INT *erchanges"]
    pub fn dgetrf_(
        m: *const ::std::os::raw::c_int,
        n: *const ::std::os::raw::c_int,
        a: *mut f64,
        lda: *const ::std::os::raw::c_int,
        ipiv: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    );
    #[doc = "DGETRI - compute the inverse of a matrix using the LU */\n/* factorization computed by DGETRF"]
    pub fn dgetri_(
        n: *const ::std::os::raw::c_int,
        a: *mut f64,
        lda: *const ::std::os::raw::c_int,
        ipiv: *mut ::std::os::raw::c_int,
        work: *mut f64,
        lwork: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    );
    #[doc = "DGETRS - solve a system of linear equations\tA * X = B or A' * */\n/* X = B with a general N-by-N matrix A using the LU factorization */\n/* computed by DGETRF"]
    pub fn dgetrs_(
        trans: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        nrhs: *const ::std::os::raw::c_int,
        a: *const f64,
        lda: *const ::std::os::raw::c_int,
        ipiv: *const ::std::os::raw::c_int,
        b: *mut f64,
        ldb: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    #[doc = "DGGBAK - form the right or left eigenvectors of a real */\n/* generalized eigenvalue problem A*x = lambda*B*x, by backward */\n/* transformation on the computed eigenvectors of the balanced */\n/* pair of matrices output by DGGBAL"]
    pub fn dggbak_(
        job: *const ::std::os::raw::c_char,
        side: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        ilo: *const ::std::os::raw::c_int,
        ihi: *const ::std::os::raw::c_int,
        lscale: *mut f64,
        rscale: *mut f64,
        m: *const ::std::os::raw::c_int,
        v: *mut f64,
        ldv: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
    );
    #[doc = "DGGBAL - balance a pair of general real matrices (A,B);"]
    pub fn dggbal_(
        job: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        a: *mut f64,
        lda: *const ::std::os::raw::c_int,
        b: *mut f64,
        ldb: *const ::std::os::raw::c_int,
        ilo: *mut ::std::os::raw::c_int,
        ihi: *mut ::std::os::raw::c_int,
        lscale: *mut f64,
        rscale: *mut f64,
        work: *mut f64,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    #[doc = "DGGES - compute for a pair of N-by-N real nonsymmetric */\n/* matrices A, B the generalized eigenvalues, the generalized */\n/* real Schur form (S,T), optionally, the left and/or right matrices */\n/* of Schur vectors (VSL and VSR)"]
    pub fn dgges_(
        jobvsl: *const ::std::os::raw::c_char,
        jobvsr: *const ::std::os::raw::c_char,
        sort: *const ::std::os::raw::c_char,
        delztg: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut f64,
                arg2: *mut f64,
                arg3: *mut f64,
            ) -> ::std::os::raw::c_int,
        >,
        n: *const ::std::os::raw::c_int,
        a: *mut f64,
        lda: *const ::std::os::raw::c_int,
        b: *mut f64,
        ldb: *const ::std::os::raw::c_int,
        alphar: *mut f64,
        alphai: *mut f64,
        beta: *const f64,
        vsl: *mut f64,
        ldvsl: *const ::std::os::raw::c_int,
        vsr: *mut f64,
        ldvsr: *const ::std::os::raw::c_int,
        work: *mut f64,
        lwork: *const ::std::os::raw::c_int,
        bwork: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
        arg3: usize,
    );
    #[doc = "DGGGLM - solve a general Gauss-Markov linear model (GLM) problem"]
    pub fn dggglm_(
        n: *const ::std::os::raw::c_int,
        m: *const ::std::os::raw::c_int,
        p: *const ::std::os::raw::c_int,
        a: *mut f64,
        lda: *const ::std::os::raw::c_int,
        b: *mut f64,
        ldb: *const ::std::os::raw::c_int,
        d: *mut f64,
        x: *mut f64,
        y: *mut f64,
        work: *mut f64,
        lwork: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    );
    #[doc = "DGGHRD - reduce a pair of real matrices (A,B); to generalized */\n/* upper Hessenberg form using orthogonal transformations, where A */\n/* is a general matrix and B is upper triangular"]
    pub fn dgghrd_(
        compq: *const ::std::os::raw::c_char,
        compz: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        ilo: *const ::std::os::raw::c_int,
        ihi: *const ::std::os::raw::c_int,
        a: *mut f64,
        lda: *const ::std::os::raw::c_int,
        b: *mut f64,
        ldb: *const ::std::os::raw::c_int,
        q: *mut f64,
        ldq: *const ::std::os::raw::c_int,
        z: *mut f64,
        ldz: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
    );
    #[doc = "DGGLSE - solve the linear equality-constrained least squares */\n/* (LSE) problem"]
    pub fn dgglse_(
        m: *const ::std::os::raw::c_int,
        n: *const ::std::os::raw::c_int,
        p: *const ::std::os::raw::c_int,
        a: *mut f64,
        lda: *const ::std::os::raw::c_int,
        b: *mut f64,
        ldb: *const ::std::os::raw::c_int,
        c: *mut f64,
        d: *mut f64,
        x: *mut f64,
        work: *mut f64,
        lwork: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    );
    #[doc = "DGGQRF - compute a generalized QR factorization of an N-by-M */\n/* matrix A and an N-by-P matrix B"]
    pub fn dggqrf_(
        n: *const ::std::os::raw::c_int,
        m: *const ::std::os::raw::c_int,
        p: *const ::std::os::raw::c_int,
        a: *mut f64,
        lda: *const ::std::os::raw::c_int,
        taua: *mut f64,
        b: *mut f64,
        ldb: *const ::std::os::raw::c_int,
        taub: *mut f64,
        work: *mut f64,
        lwork: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    );
    #[doc = "DGGRQF - compute a generalized RQ factorization of an M-by-N */\n/* matrix A and a P-by-N matrix B"]
    pub fn dggrqf_(
        m: *const ::std::os::raw::c_int,
        p: *const ::std::os::raw::c_int,
        n: *const ::std::os::raw::c_int,
        a: *mut f64,
        lda: *const ::std::os::raw::c_int,
        taua: *mut f64,
        b: *mut f64,
        ldb: *const ::std::os::raw::c_int,
        taub: *mut f64,
        work: *mut f64,
        lwork: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    );
    #[doc = "DGTCON - estimate the reciprocal of the condition number of a real */\n/* tridiagonal matrix A using the LU factorization as computed by DGTTRF"]
    pub fn dgtcon_(
        norm: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        dl: *mut f64,
        d: *mut f64,
        du: *mut f64,
        du2: *mut f64,
        ipiv: *mut ::std::os::raw::c_int,
        anorm: *const f64,
        rcond: *mut f64,
        work: *mut f64,
        iwork: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    #[doc = "DGTRFS - improve the computed solution to a system of linear equations */\n/* when the coefficient matrix is tridiagonal, and provides error bounds */\n/* and backward error estimates for the solution"]
    pub fn dgtrfs_(
        trans: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        nrhs: *const ::std::os::raw::c_int,
        dl: *mut f64,
        d: *mut f64,
        du: *mut f64,
        dlf: *mut f64,
        df: *mut f64,
        duf: *mut f64,
        du2: *mut f64,
        ipiv: *mut ::std::os::raw::c_int,
        b: *mut f64,
        ldb: *const ::std::os::raw::c_int,
        x: *mut f64,
        ldx: *const ::std::os::raw::c_int,
        ferr: *mut f64,
        berr: *mut f64,
        work: *mut f64,
        iwork: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    #[doc = "DGTSV - solve the equation\tA*X = B,"]
    pub fn dgtsv_(
        n: *const ::std::os::raw::c_int,
        nrhs: *const ::std::os::raw::c_int,
        dl: *mut f64,
        d: *mut f64,
        du: *mut f64,
        b: *mut f64,
        ldb: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    );
    #[doc = "DGTSVX - use the LU factorization to compute the solution to a */\n/* real system of linear equations A * X = B or A**T * X = B,"]
    pub fn dgtsvx_(
        fact: *const ::std::os::raw::c_int,
        trans: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        nrhs: *const ::std::os::raw::c_int,
        dl: *mut f64,
        d: *mut f64,
        du: *mut f64,
        dlf: *mut f64,
        df: *mut f64,
        duf: *mut f64,
        du2: *mut f64,
        ipiv: *mut ::std::os::raw::c_int,
        b: *mut f64,
        ldb: *const ::std::os::raw::c_int,
        x: *mut f64,
        ldx: *const ::std::os::raw::c_int,
        rcond: *mut f64,
        ferr: *mut f64,
        berr: *mut f64,
        work: *mut f64,
        iwork: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    #[doc = "DGTTRF - compute an LU factorization of a real tridiagonal matrix */\n/* A using elimination with partial pivoting and row La_INT *erchanges"]
    pub fn dgttrf_(
        n: *const ::std::os::raw::c_int,
        dl: *mut f64,
        d: *mut f64,
        du: *mut f64,
        du2: *mut f64,
        ipiv: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    );
    #[doc = "DGTTRS - solve one of the systems of equations  A*X = B or */\n/* A'*X = B,"]
    pub fn dgttrs_(
        trans: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        nrhs: *const ::std::os::raw::c_int,
        dl: *mut f64,
        d: *mut f64,
        du: *mut f64,
        du2: *mut f64,
        ipiv: *mut ::std::os::raw::c_int,
        b: *mut f64,
        ldb: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    #[doc = "DOPGTR - generate a real orthogonal matrix Q which is defined */\n/* as the product of n-1 elementary reflectors H(i); of order n, */\n/* as returned by DSPTRD using packed storage"]
    pub fn dopgtr_(
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        ap: *const f64,
        tau: *const f64,
        q: *mut f64,
        ldq: *const ::std::os::raw::c_int,
        work: *mut f64,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    #[doc = "DOPMTR - overwrite the general real M-by-N matrix C with */\n/* SIDE = 'L' SIDE = 'R' TRANS = 'N'"]
    pub fn dopmtr_(
        side: *const ::std::os::raw::c_char,
        uplo: *const ::std::os::raw::c_char,
        trans: *const ::std::os::raw::c_char,
        m: *const ::std::os::raw::c_int,
        n: *const ::std::os::raw::c_int,
        ap: *const f64,
        tau: *const f64,
        c: *mut f64,
        ldc: *const ::std::os::raw::c_int,
        work: *mut f64,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
        arg3: usize,
    );
    #[doc = "DORG2L - generate an m by n real matrix Q with orthonormal */\n/* columns,"]
    pub fn dorg2l_(
        m: *const ::std::os::raw::c_int,
        n: *const ::std::os::raw::c_int,
        k: *const ::std::os::raw::c_int,
        a: *mut f64,
        lda: *const ::std::os::raw::c_int,
        tau: *const f64,
        work: *mut f64,
        info: *mut ::std::os::raw::c_int,
    );
    #[doc = "DORG2R - generate an m by n real matrix Q with orthonormal */\n/* columns,"]
    pub fn dorg2r_(
        m: *const ::std::os::raw::c_int,
        n: *const ::std::os::raw::c_int,
        k: *const ::std::os::raw::c_int,
        a: *mut f64,
        lda: *const ::std::os::raw::c_int,
        tau: *const f64,
        work: *mut f64,
        info: *mut ::std::os::raw::c_int,
    );
    #[doc = "DORGBR - generate one of the real orthogonal matrices Q or */\n/* P**T determined by DGEBRD when reducing a real matrix A to */\n/* bidiagonal form"]
    pub fn dorgbr_(
        vect: *const ::std::os::raw::c_char,
        m: *const ::std::os::raw::c_int,
        n: *const ::std::os::raw::c_int,
        k: *const ::std::os::raw::c_int,
        a: *mut f64,
        lda: *const ::std::os::raw::c_int,
        tau: *const f64,
        work: *mut f64,
        lwork: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    #[doc = "DORGHR - generate a real orthogonal matrix Q which is defined */\n/* as the product of IHI-ILO elementary reflectors of order N, as */\n/* returned by DGEHRD"]
    pub fn dorghr_(
        n: *const ::std::os::raw::c_int,
        ilo: *const ::std::os::raw::c_int,
        ihi: *const ::std::os::raw::c_int,
        a: *mut f64,
        lda: *const ::std::os::raw::c_int,
        tau: *const f64,
        work: *mut f64,
        lwork: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    );
    #[doc = "DORGL2 - generate an m by n real matrix Q with orthonormal */\n/* rows,"]
    pub fn dorgl2_(
        m: *const ::std::os::raw::c_int,
        n: *const ::std::os::raw::c_int,
        k: *const ::std::os::raw::c_int,
        a: *mut f64,
        lda: *const ::std::os::raw::c_int,
        tau: *const f64,
        work: *mut f64,
        info: *mut ::std::os::raw::c_int,
    );
    #[doc = "DORGLQ - generate an M-by-N real matrix Q with orthonormal */\n/* rows,"]
    pub fn dorglq_(
        m: *const ::std::os::raw::c_int,
        n: *const ::std::os::raw::c_int,
        k: *const ::std::os::raw::c_int,
        a: *mut f64,
        lda: *const ::std::os::raw::c_int,
        tau: *const f64,
        work: *mut f64,
        lwork: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    );
    #[doc = "DORGQL - generate an M-by-N real matrix Q with orthonormal */\n/* columns,"]
    pub fn dorgql_(
        m: *const ::std::os::raw::c_int,
        n: *const ::std::os::raw::c_int,
        k: *const ::std::os::raw::c_int,
        a: *mut f64,
        lda: *const ::std::os::raw::c_int,
        tau: *const f64,
        work: *mut f64,
        lwork: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    );
    #[doc = "DORGQR - generate an M-by-N real matrix Q with orthonormal */\n/* columns,"]
    pub fn dorgqr_(
        m: *const ::std::os::raw::c_int,
        n: *const ::std::os::raw::c_int,
        k: *const ::std::os::raw::c_int,
        a: *mut f64,
        lda: *const ::std::os::raw::c_int,
        tau: *const f64,
        work: *mut f64,
        lwork: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    );
    #[doc = "DORGR2 - generate an m by n real matrix Q with orthonormal */\n/* rows,"]
    pub fn dorgr2_(
        m: *const ::std::os::raw::c_int,
        n: *const ::std::os::raw::c_int,
        k: *const ::std::os::raw::c_int,
        a: *mut f64,
        lda: *const ::std::os::raw::c_int,
        tau: *const f64,
        work: *mut f64,
        info: *mut ::std::os::raw::c_int,
    );
    #[doc = "DORGRQ - generate an M-by-N real matrix Q with orthonormal rows"]
    pub fn dorgrq_(
        m: *const ::std::os::raw::c_int,
        n: *const ::std::os::raw::c_int,
        k: *const ::std::os::raw::c_int,
        a: *mut f64,
        lda: *const ::std::os::raw::c_int,
        tau: *const f64,
        work: *mut f64,
        lwork: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    );
    #[doc = "DORGTR - generate a real orthogonal matrix Q which is defined */\n/* as the product of n-1 elementary reflectors of order const La_INT* n, as */\n/* returned by DSYTRD"]
    pub fn dorgtr_(
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        a: *mut f64,
        lda: *const ::std::os::raw::c_int,
        tau: *const f64,
        work: *mut f64,
        lwork: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    #[doc = "DORM2L - overwrite the general real m by n matrix C with   Q * */\n/* C if SIDE = 'L' and TRANS = 'N', or\t Q'* C if SIDE = 'L' and */\n/* TRANS = 'T', or   C * Q if SIDE = 'R' and TRANS = 'N', or   C * */\n/* Q' if SIDE = 'R' and TRANS = 'T',"]
    pub fn dorm2l_(
        side: *const ::std::os::raw::c_char,
        trans: *const ::std::os::raw::c_char,
        m: *const ::std::os::raw::c_int,
        n: *const ::std::os::raw::c_int,
        k: *const ::std::os::raw::c_int,
        a: *const f64,
        lda: *const ::std::os::raw::c_int,
        tau: *const f64,
        c: *mut f64,
        ldc: *const ::std::os::raw::c_int,
        work: *mut f64,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
    );
    #[doc = "DORM2R - overwrite the general real m by n matrix C with   Q * C */\n/* if SIDE = 'L' and TRANS = 'N', or   Q'* C if SIDE = 'L' and */\n/* TRANS = 'T', or   C * Q if SIDE = 'R' and TRANS = 'N', or   C * */\n/* Q' if SIDE = 'R' and TRANS = 'T',"]
    pub fn dorm2r_(
        side: *const ::std::os::raw::c_char,
        trans: *const ::std::os::raw::c_char,
        m: *const ::std::os::raw::c_int,
        n: *const ::std::os::raw::c_int,
        k: *const ::std::os::raw::c_int,
        a: *const f64,
        lda: *const ::std::os::raw::c_int,
        tau: *const f64,
        c: *mut f64,
        ldc: *const ::std::os::raw::c_int,
        work: *mut f64,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
    );
    #[doc = "DORMBR - VECT = 'Q', DORMBR overwrites the general real M-by-N */\n/* matrix C with  SIDE = 'L' SIDE = 'R' TRANS = 'N'"]
    pub fn dormbr_(
        vect: *const ::std::os::raw::c_char,
        side: *const ::std::os::raw::c_char,
        trans: *const ::std::os::raw::c_char,
        m: *const ::std::os::raw::c_int,
        n: *const ::std::os::raw::c_int,
        k: *const ::std::os::raw::c_int,
        a: *const f64,
        lda: *const ::std::os::raw::c_int,
        tau: *const f64,
        c: *mut f64,
        ldc: *const ::std::os::raw::c_int,
        work: *mut f64,
        lwork: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
        arg3: usize,
    );
    #[doc = "DORMHR - overwrite the general real M-by-N matrix C with */\n/* SIDE = 'L' SIDE = 'R' TRANS = 'N'"]
    pub fn dormhr_(
        side: *const ::std::os::raw::c_char,
        trans: *const ::std::os::raw::c_char,
        m: *const ::std::os::raw::c_int,
        n: *const ::std::os::raw::c_int,
        ilo: *const ::std::os::raw::c_int,
        ihi: *const ::std::os::raw::c_int,
        a: *const f64,
        lda: *const ::std::os::raw::c_int,
        tau: *const f64,
        c: *mut f64,
        ldc: *const ::std::os::raw::c_int,
        work: *mut f64,
        lwork: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
    );
    #[doc = "DORML2 - overwrite the general real m by n matrix C with   Q * */\n/* C if SIDE = 'L' and TRANS = 'N', or\t Q'* C if SIDE = 'L' and */\n/* TRANS = 'T', or   C * Q if SIDE = 'R' and TRANS = 'N', or   C * */\n/* Q' if SIDE = 'R' and TRANS = 'T',"]
    pub fn dorml2_(
        side: *const ::std::os::raw::c_char,
        trans: *const ::std::os::raw::c_char,
        m: *const ::std::os::raw::c_int,
        n: *const ::std::os::raw::c_int,
        k: *const ::std::os::raw::c_int,
        a: *const f64,
        lda: *const ::std::os::raw::c_int,
        tau: *const f64,
        c: *mut f64,
        ldc: *const ::std::os::raw::c_int,
        work: *mut f64,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
    );
    #[doc = "DORMLQ - overwrite the general real M-by-N matrix C with */\n/* SIDE = 'L' SIDE = 'R' TRANS = 'N'"]
    pub fn dormlq_(
        side: *const ::std::os::raw::c_char,
        trans: *const ::std::os::raw::c_char,
        m: *const ::std::os::raw::c_int,
        n: *const ::std::os::raw::c_int,
        k: *const ::std::os::raw::c_int,
        a: *const f64,
        lda: *const ::std::os::raw::c_int,
        tau: *const f64,
        c: *mut f64,
        ldc: *const ::std::os::raw::c_int,
        work: *mut f64,
        lwork: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
    );
    #[doc = "DORMQL - overwrite the general real M-by-N matrix C with */\n/* SIDE = 'L' SIDE = 'R' TRANS = 'N'"]
    pub fn dormql_(
        side: *const ::std::os::raw::c_char,
        trans: *const ::std::os::raw::c_char,
        m: *const ::std::os::raw::c_int,
        n: *const ::std::os::raw::c_int,
        k: *const ::std::os::raw::c_int,
        a: *const f64,
        lda: *const ::std::os::raw::c_int,
        tau: *const f64,
        c: *mut f64,
        ldc: *const ::std::os::raw::c_int,
        work: *mut f64,
        lwork: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
    );
    #[doc = "DORMQR - overwrite the general real M-by-N matrix C with   SIDE = */\n/* 'L' SIDE = 'R' TRANS = 'N'"]
    pub fn dormqr_(
        side: *const ::std::os::raw::c_char,
        trans: *const ::std::os::raw::c_char,
        m: *const ::std::os::raw::c_int,
        n: *const ::std::os::raw::c_int,
        k: *const ::std::os::raw::c_int,
        a: *const f64,
        lda: *const ::std::os::raw::c_int,
        tau: *const f64,
        c: *mut f64,
        ldc: *const ::std::os::raw::c_int,
        work: *mut f64,
        lwork: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
    );
    #[doc = "DORMR2 - overwrite the general real m by n matrix C with   Q * */\n/* C if SIDE = 'L' and TRANS = 'N', or\t Q'* C if SIDE = 'L' and */\n/* TRANS = 'T', or   C * Q if SIDE = 'R' and TRANS = 'N', or   C * */\n/* Q' if SIDE = 'R' and TRANS = 'T',"]
    pub fn dormr2_(
        side: *const ::std::os::raw::c_char,
        trans: *const ::std::os::raw::c_char,
        m: *const ::std::os::raw::c_int,
        n: *const ::std::os::raw::c_int,
        k: *const ::std::os::raw::c_int,
        a: *const f64,
        lda: *const ::std::os::raw::c_int,
        tau: *const f64,
        c: *mut f64,
        ldc: *const ::std::os::raw::c_int,
        work: *mut f64,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
    );
    #[doc = "DORMRQ - overwrite the general real M-by-N matrix C with */\n/* SIDE = 'L' SIDE = 'R' TRANS = 'N'"]
    pub fn dormrq_(
        side: *const ::std::os::raw::c_char,
        trans: *const ::std::os::raw::c_char,
        m: *const ::std::os::raw::c_int,
        n: *const ::std::os::raw::c_int,
        k: *const ::std::os::raw::c_int,
        a: *const f64,
        lda: *const ::std::os::raw::c_int,
        tau: *const f64,
        c: *mut f64,
        ldc: *const ::std::os::raw::c_int,
        work: *mut f64,
        lwork: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
    );
    #[doc = "DORMTR - overwrite the general real M-by-N matrix C with */\n/* SIDE = 'L' SIDE = 'R' TRANS = 'N'"]
    pub fn dormtr_(
        side: *const ::std::os::raw::c_char,
        uplo: *const ::std::os::raw::c_char,
        trans: *const ::std::os::raw::c_char,
        m: *const ::std::os::raw::c_int,
        n: *const ::std::os::raw::c_int,
        a: *const f64,
        lda: *const ::std::os::raw::c_int,
        tau: *const f64,
        c: *mut f64,
        ldc: *const ::std::os::raw::c_int,
        work: *mut f64,
        lwork: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
        arg3: usize,
    );
    #[doc = "DPBCON - estimate the reciprocal of the condition number (in */\n/* the 1-norm); of a real symmetric positive definite band matrix */\n/* using the Cholesky factorization A = U**T*U or A = L*L**T */\n/* computed by DPBTRF"]
    pub fn dpbcon_(
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        kd: *const ::std::os::raw::c_int,
        ab: *const f64,
        ldab: *const ::std::os::raw::c_int,
        anorm: *const f64,
        rcond: *mut f64,
        work: *mut f64,
        iwork: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    #[doc = "DPBEQU - compute row and column scalings La_INT *ended to */\n/* equilibrate a symmetric positive definite band matrix A and */\n/* reduce its condition number (with respect to the two-norm);"]
    pub fn dpbequ_(
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        kd: *const ::std::os::raw::c_int,
        ab: *const f64,
        ldab: *const ::std::os::raw::c_int,
        s: *mut f64,
        scond: *mut f64,
        amax: *mut f64,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    #[doc = "DPBRFS - improve the computed solution to a system of linear */\n/* equations when the coefficient matrix is symmetric positive */\n/* definite and banded, and provides error bounds and backward */\n/* error estimates for the solution"]
    pub fn dpbrfs_(
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        kd: *const ::std::os::raw::c_int,
        nrhs: *const ::std::os::raw::c_int,
        ab: *const f64,
        ldab: *const ::std::os::raw::c_int,
        afb: *const f64,
        ldafb: *const ::std::os::raw::c_int,
        b: *const f64,
        ldb: *const ::std::os::raw::c_int,
        x: *mut f64,
        ldx: *const ::std::os::raw::c_int,
        ferr: *mut f64,
        berr: *mut f64,
        work: *mut f64,
        iwork: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    #[doc = "DPBSTF - compute a split Cholesky factorization of a real */\n/* symmetric positive definite band matrix A"]
    pub fn dpbstf_(
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        kd: *const ::std::os::raw::c_int,
        ab: *mut f64,
        ldab: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    #[doc = "DPBSV - compute the solution to a real system of linear */\n/* equations  A * X = B,"]
    pub fn dpbsv_(
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        kd: *const ::std::os::raw::c_int,
        nrhs: *const ::std::os::raw::c_int,
        ab: *mut f64,
        ldab: *const ::std::os::raw::c_int,
        b: *mut f64,
        ldb: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    #[doc = "DPBSVX - use the Cholesky factorization A = U**T*U or A = */\n/* L*L**T to compute the solution to a real system of linear */\n/* equations  A * X = B,"]
    pub fn dpbsvx_(
        fact: *const ::std::os::raw::c_int,
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        kd: *const ::std::os::raw::c_int,
        nrhs: *const ::std::os::raw::c_int,
        ab: *mut f64,
        ldab: *const ::std::os::raw::c_int,
        afb: *mut f64,
        ldafb: *const ::std::os::raw::c_int,
        equed: *mut ::std::os::raw::c_char,
        s: *mut f64,
        b: *mut f64,
        ldb: *const ::std::os::raw::c_int,
        x: *mut f64,
        ldx: *const ::std::os::raw::c_int,
        rcond: *mut f64,
        ferr: *mut f64,
        berr: *mut f64,
        work: *mut f64,
        iwork: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
    );
    #[doc = "DPBTF2 - compute the Cholesky factorization of a real */\n/* symmetric positive definite band matrix A"]
    pub fn dpbtf2_(
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        kd: *const ::std::os::raw::c_int,
        ab: *mut f64,
        ldab: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    #[doc = "DPBTRF - compute the Cholesky factorization of a real */\n/* symmetric positive definite band matrix A"]
    pub fn dpbtrf_(
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        kd: *const ::std::os::raw::c_int,
        ab: *mut f64,
        ldab: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    #[doc = "DPBTRS - solve a system of linear equations A*X = B with a */\n/* symmetric positive definite band matrix A using the Cholesky */\n/* factorization A = U**T*U or A = L*L**T computed by DPBTRF"]
    pub fn dpbtrs_(
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        kd: *const ::std::os::raw::c_int,
        nrhs: *const ::std::os::raw::c_int,
        ab: *const f64,
        ldab: *const ::std::os::raw::c_int,
        b: *mut f64,
        ldb: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    #[doc = "DPOCON - estimate the reciprocal of the condition number (in */\n/* the 1-norm); of a real symmetric positive definite matrix using */\n/* the Cholesky factorization A = U**T*U or A = L*L**T computed by */\n/* DPOTRF"]
    pub fn dpocon_(
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        a: *const f64,
        lda: *const ::std::os::raw::c_int,
        anorm: *const f64,
        rcond: *mut f64,
        work: *mut f64,
        iwork: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    #[doc = "DPOEQU - compute row and column scalings La_INT *ended to */\n/* equilibrate a symmetric positive definite matrix A and reduce */\n/* its condition number (with respect to the two-norm);"]
    pub fn dpoequ_(
        n: *const ::std::os::raw::c_int,
        a: *const f64,
        lda: *const ::std::os::raw::c_int,
        s: *mut f64,
        scond: *mut f64,
        amax: *mut f64,
        info: *mut ::std::os::raw::c_int,
    );
    #[doc = "DPORFS - improve the computed solution to a system of linear */\n/* equations when the coefficient matrix is symmetric positive */\n/* definite,"]
    pub fn dporfs_(
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        nrhs: *const ::std::os::raw::c_int,
        a: *const f64,
        lda: *const ::std::os::raw::c_int,
        af: *const f64,
        ldaf: *const ::std::os::raw::c_int,
        b: *const f64,
        ldb: *const ::std::os::raw::c_int,
        x: *mut f64,
        ldx: *const ::std::os::raw::c_int,
        ferr: *mut f64,
        berr: *mut f64,
        work: *mut f64,
        iwork: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    #[doc = "DPOSV - compute the solution to a real system of linear */\n/* equations  A * X = B,"]
    pub fn dposv_(
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        nrhs: *const ::std::os::raw::c_int,
        a: *mut f64,
        lda: *const ::std::os::raw::c_int,
        b: *mut f64,
        ldb: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    #[doc = "DPOSVX - use the Cholesky factorization A = U**T*U or A = */\n/* L*L**T to compute the solution to a real system of linear */\n/* equations  A * X = B,"]
    pub fn dposvx_(
        fact: *const ::std::os::raw::c_int,
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        nrhs: *const ::std::os::raw::c_int,
        a: *mut f64,
        lda: *const ::std::os::raw::c_int,
        af: *mut f64,
        ldaf: *const ::std::os::raw::c_int,
        equed: *const ::std::os::raw::c_char,
        s: *mut f64,
        b: *mut f64,
        ldb: *const ::std::os::raw::c_int,
        x: *mut f64,
        ldx: *const ::std::os::raw::c_int,
        rcond: *mut f64,
        ferr: *mut f64,
        berr: *mut f64,
        work: *mut f64,
        iwork: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
    );
    #[doc = "DPOTF2 - compute the Cholesky factorization of a real */\n/* symmetric positive definite matrix A"]
    pub fn dpotf2_(
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        a: *mut f64,
        lda: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    #[doc = "DPOTRF - compute the Cholesky factorization of a real */\n/* symmetric positive definite matrix A"]
    pub fn dpotrf_(
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        a: *mut f64,
        lda: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    #[doc = "DPOTRI - compute the inverse of a real symmetric positive */\n/* definite matrix A using the Cholesky factorization A = U**T*U */\n/* or A = L*L**T computed by DPOTRF"]
    pub fn dpotri_(
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        a: *mut f64,
        lda: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    #[doc = "DPOTRS - solve a system of linear equations A*X = B with a */\n/* symmetric positive definite matrix A using the Cholesky */\n/* factorization A = U**T*U or A = L*L**T computed by DPOTRF"]
    pub fn dpotrs_(
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        nrhs: *const ::std::os::raw::c_int,
        a: *const f64,
        lda: *const ::std::os::raw::c_int,
        b: *mut f64,
        ldb: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    #[doc = "DPPCON - estimate the reciprocal of the condition number (in */\n/* the 1-norm); of a real symmetric positive definite packed */\n/* matrix using the Cholesky factorization A = U**T*U or A = */\n/* L*L**T computed by DPPTRF"]
    pub fn dppcon_(
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        ap: *const f64,
        anorm: *const f64,
        rcond: *mut f64,
        work: *mut f64,
        iwork: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    #[doc = "DPPEQU - compute row and column scalings La_INT *ended to */\n/* equilibrate a symmetric positive definite matrix A in packed */\n/* storage and reduce its condition number (with respect to the */\n/* two-norm);"]
    pub fn dppequ_(
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        ap: *const f64,
        s: *mut f64,
        scond: *mut f64,
        amax: *mut f64,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    #[doc = "DPPRFS - improve the computed solution to a system of linear */\n/* equations when the coefficient matrix is symmetric positive */\n/* definite and packed, and provides error bounds and backward */\n/* error estimates for the solution"]
    pub fn dpprfs_(
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        nrhs: *const ::std::os::raw::c_int,
        ap: *const f64,
        afp: *const f64,
        b: *const f64,
        ldb: *const ::std::os::raw::c_int,
        x: *mut f64,
        ldx: *const ::std::os::raw::c_int,
        ferr: *mut f64,
        berr: *mut f64,
        work: *mut f64,
        iwork: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    #[doc = "DPPSV - compute the solution to a real system of linear */\n/* equations  A * X = B,"]
    pub fn dppsv_(
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        nrhs: *const ::std::os::raw::c_int,
        ap: *const f64,
        b: *mut f64,
        ldb: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    #[doc = "DPPSVX - use the Cholesky factorization A = U**T*U or A = */\n/* L*L**T to compute the solution to a real system of linear */\n/* equations  A * X = B,"]
    pub fn dppsvx_(
        fact: *const ::std::os::raw::c_char,
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        nrhs: *const ::std::os::raw::c_int,
        ap: *mut f64,
        afp: *mut f64,
        equed: *const ::std::os::raw::c_char,
        s: *mut f64,
        b: *mut f64,
        ldb: *const ::std::os::raw::c_int,
        x: *mut f64,
        ldx: *const ::std::os::raw::c_int,
        rcond: *mut f64,
        ferr: *mut f64,
        berr: *mut f64,
        work: *mut f64,
        iwork: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
        arg3: usize,
    );
    #[doc = "DPPTRF - compute the Cholesky factorization of a real */\n/* symmetric positive definite matrix A stored in packed format"]
    pub fn dpptrf_(
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        ap: *mut f64,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    #[doc = "DPPTRI - compute the inverse of a real symmetric positive */\n/* definite matrix A using the Cholesky factorization A = U**T*U */\n/* or A = L*L**T computed by DPPTRF"]
    pub fn dpptri_(
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        ap: *mut f64,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    #[doc = "DPPTRS - solve a system of linear equations A*X = B with a */\n/* symmetric positive definite matrix A in packed storage using */\n/* the Cholesky factorization A = U**T*U or A = L*L**T computed by */\n/* DPPTRF"]
    pub fn dpptrs_(
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        nrhs: *const ::std::os::raw::c_int,
        ap: *const f64,
        b: *mut f64,
        ldb: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    #[doc = "DPTCON - compute the reciprocal of the condition number (in */\n/* the 1-norm); of a real symmetric positive definite tridiagonal */\n/* matrix using the factorization A = L*D*L**T or A = U**T*D*U */\n/* computed by DPTTRF"]
    pub fn dptcon_(
        n: *const ::std::os::raw::c_int,
        d: *const f64,
        e: *const f64,
        anorm: *const f64,
        rcond: *mut f64,
        work: *mut f64,
        info: *mut ::std::os::raw::c_int,
    );
    #[doc = "DPTEQR - compute all eigenvalues and, optionally, eigenvectors */\n/* of a symmetric positive definite tridiagonal matrix by first */\n/* factoring the matrix using DPTTRF, and then calling DBDSQR to */\n/* compute the singular values of the bidiagonal factor"]
    pub fn dpteqr_(
        compz: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        d: *mut f64,
        e: *mut f64,
        z: *mut f64,
        ldz: *const ::std::os::raw::c_int,
        work: *mut f64,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    #[doc = "DPTRFS - improve the computed solution to a system of linear */\n/* equations when the coefficient matrix is symmetric positive */\n/* definite and tridiagonal, and provides error bounds and */\n/* backward error estimates for the solution"]
    pub fn dptrfs_(
        n: *const ::std::os::raw::c_int,
        nrhs: *const ::std::os::raw::c_int,
        d: *const f64,
        e: *const f64,
        df: *const f64,
        ef: *const f64,
        b: *const f64,
        ldb: *const ::std::os::raw::c_int,
        x: *mut f64,
        ldx: *const ::std::os::raw::c_int,
        ferr: *mut f64,
        berr: *mut f64,
        work: *mut f64,
        info: *mut ::std::os::raw::c_int,
    );
    #[doc = "DPTSV - compute the solution to a real system of linear */\n/* equations A*X = B, where A is an N-by-N symmetric positive */\n/* definite tridiagonal matrix, and X and B are N-by-NRHS matrices"]
    pub fn dptsv_(
        n: *const ::std::os::raw::c_int,
        nrhs: *const ::std::os::raw::c_int,
        d: *mut f64,
        e: *mut f64,
        b: *mut f64,
        ldb: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    );
    #[doc = "DPTSVX - use the factorization A = L*D*L**T to compute the */\n/* solution to a real system of linear equations A*X = B, where A */\n/* is an N-by-N symmetric positive definite tridiagonal matrix and */\n/* X and B are N-by-NRHS matrices"]
    pub fn dptsvx_(
        fact: *const ::std::os::raw::c_int,
        n: *const ::std::os::raw::c_int,
        nrhs: *const ::std::os::raw::c_int,
        d: *const f64,
        e: *const f64,
        df: *mut f64,
        ef: *mut f64,
        b: *const f64,
        ldb: *const ::std::os::raw::c_int,
        x: *mut f64,
        ldx: *const ::std::os::raw::c_int,
        rcond: *mut f64,
        ferr: *mut f64,
        berr: *mut f64,
        work: *mut f64,
        info: *mut ::std::os::raw::c_int,
    );
    #[doc = "DPTTRF - compute the factorization of a real symmetric */\n/* positive definite tridiagonal matrix A"]
    pub fn dpttrf_(
        n: *const ::std::os::raw::c_int,
        d: *mut f64,
        e: *mut f64,
        info: *mut ::std::os::raw::c_int,
    );
    #[doc = "DPTTRS - solve a system of linear equations A * X = B with a */\n/* symmetric positive definite tridiagonal matrix A using the */\n/* factorization A = L*D*L**T or A = U**T*D*U computed by DPTTRF"]
    pub fn dpttrs_(
        n: *const ::std::os::raw::c_int,
        nrhs: *const ::std::os::raw::c_int,
        d: *const f64,
        e: *const f64,
        b: *mut f64,
        ldb: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    );
    #[doc = "DRSCL - multiply an n-element real vector x by the real scalar */\n/* 1/a"]
    pub fn drscl_(
        n: *const ::std::os::raw::c_int,
        da: *const f64,
        x: *mut f64,
        incx: *const ::std::os::raw::c_int,
    );
    #[doc = "DSBEV - compute all the eigenvalues and, optionally, */\n/* eigenvectors of a real symmetric band matrix A"]
    pub fn dsbev_(
        jobz: *const ::std::os::raw::c_char,
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        kd: *const ::std::os::raw::c_int,
        ab: *mut f64,
        ldab: *const ::std::os::raw::c_int,
        w: *mut f64,
        z: *mut f64,
        ldz: *const ::std::os::raw::c_int,
        work: *mut f64,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
    );
    #[doc = "DSBEVD - compute all the eigenvalues and, optionally, */\n/* eigenvectors of a real symmetric band matrix A"]
    pub fn dsbevd_(
        jobz: *const ::std::os::raw::c_char,
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        kd: *const ::std::os::raw::c_int,
        ab: *mut f64,
        ldab: *const ::std::os::raw::c_int,
        w: *mut f64,
        z: *mut f64,
        ldz: *const ::std::os::raw::c_int,
        work: *mut f64,
        lwork: *const ::std::os::raw::c_int,
        iwork: *mut ::std::os::raw::c_int,
        liwork: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
    );
    #[doc = "DSBEVX - compute selected eigenvalues and, optionally, */\n/* eigenvectors of a real symmetric band matrix A"]
    pub fn dsbevx_(
        jobz: *const ::std::os::raw::c_char,
        range: *const ::std::os::raw::c_char,
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        kd: *const ::std::os::raw::c_int,
        ab: *mut f64,
        ldab: *const ::std::os::raw::c_int,
        q: *mut f64,
        ldq: *const ::std::os::raw::c_int,
        vl: *const f64,
        vu: *const f64,
        il: *const ::std::os::raw::c_int,
        iu: *const ::std::os::raw::c_int,
        abstol: *const f64,
        m: *mut ::std::os::raw::c_int,
        w: *mut f64,
        z: *mut f64,
        ldz: *const ::std::os::raw::c_int,
        work: *mut f64,
        iwork: *mut ::std::os::raw::c_int,
        ifail: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
        arg3: usize,
    );
    #[doc = "DSBGST - reduce a real symmetric-definite banded generalized */\n/* eigenproblem A*x = lambda*B*x to standard form C*y = lambda*y,"]
    pub fn dsbgst_(
        vect: *const ::std::os::raw::c_char,
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        ka: *const ::std::os::raw::c_int,
        kb: *const ::std::os::raw::c_int,
        ab: *mut f64,
        ldab: *const ::std::os::raw::c_int,
        bb: *mut f64,
        ldbb: *const ::std::os::raw::c_int,
        x: *mut f64,
        ldx: *const ::std::os::raw::c_int,
        work: *mut f64,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
    );
    #[doc = "DSBGV - compute all the eigenvalues, and optionally, the */\n/* eigenvectors of a real generalized symmetric-definite banded */\n/* eigenproblem, of the form A*x=(lambda);*B*x"]
    pub fn dsbgv_(
        jobz: *const ::std::os::raw::c_char,
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        ka: *const ::std::os::raw::c_int,
        kb: *const ::std::os::raw::c_int,
        ab: *mut f64,
        ldab: *const ::std::os::raw::c_int,
        bb: *mut f64,
        ldbb: *const ::std::os::raw::c_int,
        w: *mut f64,
        z: *mut f64,
        ldz: *const ::std::os::raw::c_int,
        work: *mut f64,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
    );
    #[doc = "DSBTRD - reduce a real symmetric band matrix A to symmetric */\n/* tridiagonal form T by an orthogonal similarity transformation"]
    pub fn dsbtrd_(
        vect: *const ::std::os::raw::c_char,
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        kd: *const ::std::os::raw::c_int,
        ab: *mut f64,
        ldab: *const ::std::os::raw::c_int,
        d: *mut f64,
        e: *mut f64,
        q: *mut f64,
        ldq: *const ::std::os::raw::c_int,
        work: *mut f64,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
    );
    #[doc = "DSPCON - estimate the reciprocal of the condition number (in */\n/* the 1-norm); of a real symmetric packed matrix A using the */\n/* factorization A = U*D*U**T or A = L*D*L**T computed by DSPTRF"]
    pub fn dspcon_(
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        ap: *const f64,
        ipiv: *const ::std::os::raw::c_int,
        anorm: *const f64,
        rcond: *mut f64,
        work: *mut f64,
        iwork: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    #[doc = "DSPEV - compute all the eigenvalues and, optionally, */\n/* eigenvectors of a real symmetric matrix A in packed storage"]
    pub fn dspev_(
        jobz: *const ::std::os::raw::c_char,
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        ap: *mut f64,
        w: *mut f64,
        z: *mut f64,
        ldz: *const ::std::os::raw::c_int,
        work: *mut f64,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
    );
    #[doc = "DSPEVD - compute all the eigenvalues and, optionally, */\n/* eigenvectors of a real symmetric matrix A in packed storage"]
    pub fn dspevd_(
        jobz: *const ::std::os::raw::c_char,
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        ap: *mut f64,
        w: *mut f64,
        z: *mut f64,
        ldz: *const ::std::os::raw::c_int,
        work: *mut f64,
        lwork: *const ::std::os::raw::c_int,
        iwork: *mut ::std::os::raw::c_int,
        liwork: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
    );
    #[doc = "DSPEVX - compute selected eigenvalues and, optionally, */\n/* eigenvectors of a real symmetric matrix A in packed storage"]
    pub fn dspevx_(
        jobz: *const ::std::os::raw::c_char,
        range: *const ::std::os::raw::c_char,
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        ap: *mut f64,
        vl: *const f64,
        vu: *const f64,
        il: *const ::std::os::raw::c_int,
        iu: *const ::std::os::raw::c_int,
        abstol: *const f64,
        m: *mut ::std::os::raw::c_int,
        w: *mut f64,
        z: *mut f64,
        ldz: *const ::std::os::raw::c_int,
        work: *mut f64,
        iwork: *mut ::std::os::raw::c_int,
        ifail: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
        arg3: usize,
    );
    #[doc = "DSPGST - reduce a real symmetric-definite generalized */\n/* eigenproblem to standard form, using packed storage"]
    pub fn dspgst_(
        itype: *const ::std::os::raw::c_int,
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        ap: *mut f64,
        bp: *mut f64,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    #[doc = "DSPGV - compute all the eigenvalues and, optionally, the */\n/* eigenvectors of a real generalized symmetric-definite */\n/* eigenproblem, of the form A*x=(lambda)*B*x, A*Bx=(lambda)*x, */\n/* or B*A*x=(lambda)*x"]
    pub fn dspgv_(
        itype: *const ::std::os::raw::c_int,
        jobz: *const ::std::os::raw::c_char,
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        ap: *mut f64,
        bp: *mut f64,
        w: *mut f64,
        z: *mut f64,
        ldz: *const ::std::os::raw::c_int,
        work: *mut f64,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
        arg3: usize,
    );
    #[doc = "DSPRFS - improve the computed solution to a system of linear */\n/* equations when the coefficient matrix is symmetric indefinite */\n/* and packed, and provides error bounds and backward error */\n/* estimates for the solution"]
    pub fn dsprfs_(
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        nrhs: *const ::std::os::raw::c_int,
        ap: *const f64,
        afp: *const f64,
        ipiv: *const ::std::os::raw::c_int,
        b: *const f64,
        ldb: *const ::std::os::raw::c_int,
        x: *mut f64,
        ldx: *const ::std::os::raw::c_int,
        ferr: *mut f64,
        berr: *mut f64,
        work: *mut f64,
        iwork: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    #[doc = "DSPSV - compute the solution to a real system of linear */\n/* equations  A * X = B,"]
    pub fn dspsv_(
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        nrhs: *const ::std::os::raw::c_int,
        ap: *mut f64,
        ipiv: *mut ::std::os::raw::c_int,
        b: *mut f64,
        ldb: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    #[doc = "DSPSVX - use the diagonal pivoting factorization A = U*D*U**T */\n/* or A = L*D*L**T to compute the solution to a real system of */\n/* linear equations A * X = B, where A is an N-by-N symmetric */\n/* matrix stored in packed format and X and B are N-by-NRHS */\n/* matrices"]
    pub fn dspsvx_(
        fact: *const ::std::os::raw::c_int,
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        nrhs: *const ::std::os::raw::c_int,
        ap: *const f64,
        afp: *mut f64,
        ipiv: *mut ::std::os::raw::c_int,
        b: *const f64,
        ldb: *const ::std::os::raw::c_int,
        x: *mut f64,
        ldx: *const ::std::os::raw::c_int,
        rcond: *mut f64,
        ferr: *mut f64,
        berr: *mut f64,
        work: *mut f64,
        iwork: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    #[doc = "DSPTRD - reduce a real symmetric matrix A stored in packed */\n/* form to symmetric tridiagonal form T by an orthogonal */\n/* similarity transformation"]
    pub fn dsptrd_(
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        ap: *mut f64,
        d: *mut f64,
        e: *mut f64,
        tau: *mut f64,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    #[doc = "DSPTRF - compute the factorization of a real symmetric matrix */\n/* A stored in packed format using the Bunch-Kaufman diagonal */\n/* pivoting method"]
    pub fn dsptrf_(
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        ap: *mut f64,
        ipiv: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    #[doc = "DSPTRI - compute the inverse of a real symmetric indefinite */\n/* matrix A in packed storage using the factorization A = U*D*U**T */\n/* or A = L*D*L**T computed by DSPTRF"]
    pub fn dsptri_(
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        ap: *mut f64,
        ipiv: *const ::std::os::raw::c_int,
        work: *mut f64,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    #[doc = "DSPTRS - solve a system of linear equations A*X = B with a */\n/* real symmetric matrix A stored in packed format using the */\n/* factorization A = U*D*U**T or A = L*D*L**T computed by DSPTRF"]
    pub fn dsptrs_(
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        nrhs: *const ::std::os::raw::c_int,
        ap: *const f64,
        ipiv: *const ::std::os::raw::c_int,
        b: *mut f64,
        ldb: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    #[doc = "DSTEBZ - compute the eigenvalues of a symmetric tridiagonal */\n/* matrix T"]
    pub fn dstebz_(
        range: *const ::std::os::raw::c_char,
        order: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        vl: *const f64,
        vu: *const f64,
        il: *const ::std::os::raw::c_int,
        iu: *const ::std::os::raw::c_int,
        abstol: *const f64,
        d: *const f64,
        e: *const f64,
        m: *mut ::std::os::raw::c_int,
        nsplit: *mut ::std::os::raw::c_int,
        w: *mut f64,
        iblock: *mut ::std::os::raw::c_int,
        isplit: *mut ::std::os::raw::c_int,
        work: *mut f64,
        iwork: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
    );
    #[doc = "DSTEDC - compute all eigenvalues and, optionally, eigenvectors */\n/* of a symmetric tridiagonal matrix using the divide and conquer */\n/* method"]
    pub fn dstedc_(
        compz: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        d: *mut f64,
        e: *mut f64,
        z: *mut f64,
        ldz: *const ::std::os::raw::c_int,
        work: *mut f64,
        lwork: *const ::std::os::raw::c_int,
        iwork: *mut ::std::os::raw::c_int,
        liwork: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    #[doc = "DSTEIN - compute the eigenvectors of a real symmetric */\n/* tridiagonal matrix T corresponding to specified eigenvalues, */\n/* using inverse iteration"]
    pub fn dstein_(
        n: *const ::std::os::raw::c_int,
        d: *const f64,
        e: *const f64,
        m: *const ::std::os::raw::c_int,
        w: *const f64,
        iblock: *const ::std::os::raw::c_int,
        isplit: *const ::std::os::raw::c_int,
        z: *mut f64,
        ldz: *const ::std::os::raw::c_int,
        work: *mut f64,
        iwork: *mut ::std::os::raw::c_int,
        ifail: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    );
    #[doc = "DSTEQR - compute all eigenvalues and, optionally, eigenvectors */\n/* of a symmetric tridiagonal matrix using the implicit QL or QR */\n/* method"]
    pub fn dsteqr_(
        compz: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        d: *mut f64,
        e: *mut f64,
        z: *mut f64,
        ldz: *const ::std::os::raw::c_int,
        work: *mut f64,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    #[doc = "DSTERF - compute all eigenvalues of a symmetric tridiagonal */\n/* matrix using the Pal-Walker-Kahan variant of the QL or QR */\n/* algorithm"]
    pub fn dsterf_(
        n: *const ::std::os::raw::c_int,
        d: *mut f64,
        e: *mut f64,
        info: *mut ::std::os::raw::c_int,
    );
    #[doc = "DSTEV - compute all eigenvalues and, optionally, eigenvectors */\n/* of a real symmetric tridiagonal matrix A"]
    pub fn dstev_(
        jobz: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        d: *mut f64,
        e: *mut f64,
        z: *mut f64,
        ldz: *const ::std::os::raw::c_int,
        work: *mut f64,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    #[doc = "DSTEVD - compute all eigenvalues and, optionally, eigenvectors */\n/* of a real symmetric tridiagonal matrix"]
    pub fn dstevd_(
        jobz: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        d: *mut f64,
        e: *mut f64,
        z: *mut f64,
        ldz: *const ::std::os::raw::c_int,
        work: *mut f64,
        lwork: *const ::std::os::raw::c_int,
        iwork: *mut ::std::os::raw::c_int,
        liwork: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    #[doc = "DSTEVX - compute selected eigenvalues and, optionally, */\n/* eigenvectors of a real symmetric tridiagonal matrix A"]
    pub fn dstevx_(
        jobz: *const ::std::os::raw::c_char,
        range: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        d: *mut f64,
        e: *mut f64,
        vl: *const f64,
        vu: *const f64,
        il: *const ::std::os::raw::c_int,
        iu: *const ::std::os::raw::c_int,
        abstol: *const f64,
        m: *mut ::std::os::raw::c_int,
        w: *mut f64,
        z: *mut f64,
        ldz: *const ::std::os::raw::c_int,
        work: *mut f64,
        iwork: *mut ::std::os::raw::c_int,
        ifail: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
    );
    #[doc = "DSYCON - estimate the reciprocal of the condition number (in */\n/* the 1-norm); of a real symmetric matrix A using the */\n/* factorization A = U*D*U**T or A = L*D*L**T computed by DSYTRF"]
    pub fn dsycon_(
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        a: *const f64,
        lda: *const ::std::os::raw::c_int,
        ipiv: *const ::std::os::raw::c_int,
        anorm: *const f64,
        rcond: *mut f64,
        work: *mut f64,
        iwork: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    #[doc = "DSYEV - compute all eigenvalues and, optionally, eigenvectors */\n/* of a real symmetric matrix A"]
    pub fn dsyev_(
        jobz: *const ::std::os::raw::c_char,
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        a: *mut f64,
        lda: *const ::std::os::raw::c_int,
        w: *mut f64,
        work: *mut f64,
        lwork: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
    );
    #[doc = "DSYEVD - compute all eigenvalues and, optionally, eigenvectors */\n/* of a real symmetric matrix A"]
    pub fn dsyevd_(
        jobz: *const ::std::os::raw::c_char,
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        a: *mut f64,
        lda: *const ::std::os::raw::c_int,
        w: *mut f64,
        work: *mut f64,
        lwork: *const ::std::os::raw::c_int,
        iwork: *mut ::std::os::raw::c_int,
        liwork: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
    );
    #[doc = "DSYEVX - compute selected eigenvalues and, optionally, */\n/* eigenvectors of a real symmetric matrix A"]
    pub fn dsyevx_(
        jobz: *const ::std::os::raw::c_char,
        range: *const ::std::os::raw::c_char,
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        a: *mut f64,
        lda: *const ::std::os::raw::c_int,
        vl: *const f64,
        vu: *const f64,
        il: *const ::std::os::raw::c_int,
        iu: *const ::std::os::raw::c_int,
        abstol: *const f64,
        m: *mut ::std::os::raw::c_int,
        w: *mut f64,
        z: *mut f64,
        ldz: *const ::std::os::raw::c_int,
        work: *mut f64,
        lwork: *const ::std::os::raw::c_int,
        iwork: *mut ::std::os::raw::c_int,
        ifail: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
        arg3: usize,
    );
    #[doc = "DSYEVR - compute all eigenvalues and, optionally, eigenvectors   */\n/* of a real symmetric matrix A"]
    pub fn dsyevr_(
        jobz: *const ::std::os::raw::c_char,
        range: *const ::std::os::raw::c_char,
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        a: *mut f64,
        lda: *const ::std::os::raw::c_int,
        vl: *const f64,
        vu: *const f64,
        il: *const ::std::os::raw::c_int,
        iu: *const ::std::os::raw::c_int,
        abstol: *const f64,
        m: *mut ::std::os::raw::c_int,
        w: *mut f64,
        z: *mut f64,
        ldz: *const ::std::os::raw::c_int,
        isuppz: *mut ::std::os::raw::c_int,
        work: *mut f64,
        lwork: *const ::std::os::raw::c_int,
        iwork: *mut ::std::os::raw::c_int,
        liwork: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
        arg3: usize,
    );
    #[doc = "DSYGS2 - reduce a real symmetric-definite generalized */\n/* eigenproblem to standard form"]
    pub fn dsygs2_(
        itype: *const ::std::os::raw::c_int,
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        a: *mut f64,
        lda: *const ::std::os::raw::c_int,
        b: *const f64,
        ldb: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    #[doc = "DSYGST - reduce a real symmetric-definite generalized */\n/* eigenproblem to standard form"]
    pub fn dsygst_(
        itype: *const ::std::os::raw::c_int,
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        a: *mut f64,
        lda: *const ::std::os::raw::c_int,
        b: *const f64,
        ldb: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    #[doc = "DSYGV - compute all the eigenvalues, and optionally, the */\n/* eigenvectors of a real generalized symmetric-definite */\n/* eigenproblem, of the form A*x=(lambda);*B*x, A*Bx=(lambda);*x, */\n/* or B*A*x=(lambda);*x"]
    pub fn dsygv_(
        itype: *const ::std::os::raw::c_int,
        jobz: *const ::std::os::raw::c_char,
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        a: *mut f64,
        lda: *const ::std::os::raw::c_int,
        b: *mut f64,
        ldb: *const ::std::os::raw::c_int,
        w: *mut f64,
        work: *mut f64,
        lwork: *const ::std::os::raw::c_int,
        info: *mut *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
    );
    #[doc = "DSYRFS - improve the computed solution to a system of linear */\n/* equations when the coefficient matrix is symmetric indefinite, */\n/* and provides error bounds and backward error estimates for the */\n/* solution"]
    pub fn dsyrfs_(
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        nrhs: *const ::std::os::raw::c_int,
        a: *const f64,
        lda: *const ::std::os::raw::c_int,
        af: *const f64,
        ldaf: *const ::std::os::raw::c_int,
        ipiv: *const ::std::os::raw::c_int,
        b: *const f64,
        ldb: *const ::std::os::raw::c_int,
        x: *mut f64,
        ldx: *const ::std::os::raw::c_int,
        ferr: *mut f64,
        berr: *mut f64,
        work: *mut f64,
        iwork: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    #[doc = "DSYSV - compute the solution to a real system of linear */\n/* equations  A * X = B,"]
    pub fn dsysv_(
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        nrhs: *const ::std::os::raw::c_int,
        a: *mut f64,
        lda: *const ::std::os::raw::c_int,
        ipiv: *mut ::std::os::raw::c_int,
        b: *mut f64,
        ldb: *const ::std::os::raw::c_int,
        work: *mut f64,
        lwork: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    #[doc = "DSYSVX - use the diagonal pivoting factorization to compute */\n/* the solution to a real system of linear equations A * X = B,"]
    pub fn dsysvx_(
        fact: *const ::std::os::raw::c_int,
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        nrhs: *const ::std::os::raw::c_int,
        a: *const f64,
        lda: *const ::std::os::raw::c_int,
        af: *mut f64,
        ldaf: *const ::std::os::raw::c_int,
        ipiv: *mut ::std::os::raw::c_int,
        b: *const f64,
        ldb: *const ::std::os::raw::c_int,
        x: *mut f64,
        ldx: *const ::std::os::raw::c_int,
        rcond: *mut f64,
        ferr: *mut f64,
        berr: *mut f64,
        work: *mut f64,
        lwork: *const ::std::os::raw::c_int,
        iwork: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    #[doc = "DSYTD2 - reduce a real symmetric matrix A to symmetric */\n/* tridiagonal form T by an orthogonal similarity transformation"]
    pub fn dsytd2_(
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        a: *mut f64,
        lda: *const ::std::os::raw::c_int,
        d: *mut f64,
        e: *mut f64,
        tau: *mut f64,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    #[doc = "DSYTF2 - compute the factorization of a real symmetric matrix */\n/* A using the Bunch-Kaufman diagonal pivoting method"]
    pub fn dsytf2_(
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        a: *mut f64,
        lda: *const ::std::os::raw::c_int,
        ipiv: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    #[doc = "DSYTRD - reduce a real symmetric matrix A to real symmetric */\n/* tridiagonal form T by an orthogonal similarity transformation"]
    pub fn dsytrd_(
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        a: *mut f64,
        lda: *const ::std::os::raw::c_int,
        d: *mut f64,
        e: *mut f64,
        tau: *mut f64,
        work: *mut f64,
        lwork: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    #[doc = "DSYTRF - compute the factorization of a real symmetric matrix */\n/* A using the Bunch-Kaufman diagonal pivoting method"]
    pub fn dsytrf_(
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        a: *mut f64,
        lda: *const ::std::os::raw::c_int,
        ipiv: *mut ::std::os::raw::c_int,
        work: *mut f64,
        lwork: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    #[doc = "DSYTRI - compute the inverse of a real symmetric indefinite */\n/* matrix A using the factorization A = U*D*U**T or A = L*D*L**T */\n/* computed by DSYTRF"]
    pub fn dsytri_(
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        a: *mut f64,
        lda: *const ::std::os::raw::c_int,
        ipiv: *const ::std::os::raw::c_int,
        work: *mut f64,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    #[doc = "DSYTRS - solve a system of linear equations A*X = B with a */\n/* real symmetric matrix A using the factorization A = U*D*U**T or */\n/* A = L*D*L**T computed by DSYTRF"]
    pub fn dsytrs_(
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        nrhs: *const ::std::os::raw::c_int,
        a: *const f64,
        lda: *const ::std::os::raw::c_int,
        ipiv: *const ::std::os::raw::c_int,
        b: *mut f64,
        ldb: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    #[doc = "DTBCON - estimate the reciprocal of the condition number of a */\n/* triangular band matrix A, in either the 1-norm or the */\n/* infinity-norm"]
    pub fn dtbcon_(
        norm: *const ::std::os::raw::c_char,
        uplo: *const ::std::os::raw::c_char,
        diag: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        kd: *const ::std::os::raw::c_int,
        ab: *const f64,
        ldab: *const ::std::os::raw::c_int,
        rcond: *mut f64,
        work: *mut f64,
        iwork: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
        arg3: usize,
    );
    #[doc = "DTBRFS - provide error bounds and backward error estimates for */\n/* the solution to a system of linear equations with a triangular */\n/* band coefficient matrix"]
    pub fn dtbrfs_(
        uplo: *const ::std::os::raw::c_char,
        trans: *const ::std::os::raw::c_char,
        diag: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        kd: *const ::std::os::raw::c_int,
        nrhs: *const ::std::os::raw::c_int,
        ab: *const f64,
        ldab: *const ::std::os::raw::c_int,
        b: *const f64,
        ldb: *const ::std::os::raw::c_int,
        x: *mut f64,
        ldx: *const ::std::os::raw::c_int,
        ferr: *mut f64,
        berr: *mut f64,
        work: *mut f64,
        iwork: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
        arg3: usize,
    );
    #[doc = "DTBTRS - solve a triangular system of the form   A * X = B or */\n/* A**T * X = B,"]
    pub fn dtbtrs_(
        uplo: *const ::std::os::raw::c_char,
        trans: *const ::std::os::raw::c_char,
        diag: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        kd: *const ::std::os::raw::c_int,
        nrhs: *const ::std::os::raw::c_int,
        ab: *const f64,
        ldab: *const ::std::os::raw::c_int,
        b: *mut f64,
        ldb: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
        arg3: usize,
    );
    #[doc = "DTGEVC - compute some or all of the right and/or left */\n/* generalized eigenvectors of a pair of real upper triangular */\n/* matrices (A,B);"]
    pub fn dtgevc_(
        side: *const ::std::os::raw::c_char,
        howmny: *const ::std::os::raw::c_char,
        select: *const ::std::os::raw::c_int,
        n: *const ::std::os::raw::c_int,
        a: *const f64,
        lda: *const ::std::os::raw::c_int,
        b: *const f64,
        ldb: *const ::std::os::raw::c_int,
        vl: *mut f64,
        ldvl: *const ::std::os::raw::c_int,
        vr: *mut f64,
        ldvr: *const ::std::os::raw::c_int,
        mm: *const ::std::os::raw::c_int,
        m: *mut ::std::os::raw::c_int,
        work: *mut f64,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
    );
    #[doc = "DTGSJA - compute the generalized singular value decomposition */\n/* (GSVD); of two real upper triangular (or trapezoidal); matrices */\n/* A and B"]
    pub fn dtgsja_(
        jobu: *const ::std::os::raw::c_char,
        jobv: *const ::std::os::raw::c_char,
        jobq: *const ::std::os::raw::c_char,
        m: *const ::std::os::raw::c_int,
        p: *const ::std::os::raw::c_int,
        n: *const ::std::os::raw::c_int,
        k: *const ::std::os::raw::c_int,
        l: *const ::std::os::raw::c_int,
        a: *mut f64,
        lda: *const ::std::os::raw::c_int,
        b: *mut f64,
        ldb: *const ::std::os::raw::c_int,
        tola: *const f64,
        tolb: *const f64,
        alpha: *mut f64,
        beta: *mut f64,
        u: *mut f64,
        ldu: *const ::std::os::raw::c_int,
        v: *mut f64,
        ldv: *const ::std::os::raw::c_int,
        q: *mut f64,
        ldq: *const ::std::os::raw::c_int,
        work: *mut f64,
        ncycle: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
        arg3: usize,
    );
    #[doc = "DTPCON - estimate the reciprocal of the condition number of a */\n/* packed triangular matrix A, in either the 1-norm or the */\n/* infinity-norm"]
    pub fn dtpcon_(
        norm: *const ::std::os::raw::c_char,
        uplo: *const ::std::os::raw::c_char,
        diag: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        ap: *const f64,
        rcond: *mut f64,
        work: *mut f64,
        iwork: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
        arg3: usize,
    );
    #[doc = "DTPRFS - provide error bounds and backward error estimates for */\n/* the solution to a system of linear equations with a triangular */\n/* packed coefficient matrix"]
    pub fn dtprfs_(
        uplo: *const ::std::os::raw::c_char,
        trans: *const ::std::os::raw::c_char,
        diag: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        nrhs: *const ::std::os::raw::c_int,
        ap: *const f64,
        b: *const f64,
        ldb: *const ::std::os::raw::c_int,
        x: *mut f64,
        ldx: *const ::std::os::raw::c_int,
        ferr: *mut f64,
        berr: *mut f64,
        work: *mut f64,
        iwork: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
        arg3: usize,
    );
    #[doc = "DTPTRI - compute the inverse of a real upper or lower */\n/* triangular matrix A stored in packed format"]
    pub fn dtptri_(
        uplo: *const ::std::os::raw::c_char,
        diag: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        ap: *mut f64,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
    );
    #[doc = "DTPTRS - solve a triangular system of the form   A * X = B or */\n/* A**T * X = B,"]
    pub fn dtptrs_(
        uplo: *const ::std::os::raw::c_char,
        trans: *const ::std::os::raw::c_char,
        diag: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        nrhs: *const ::std::os::raw::c_int,
        ap: *const f64,
        b: *mut f64,
        ldb: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
    );
    #[doc = "DTRCON - estimate the reciprocal of the condition number of a */\n/* triangular matrix A, in either the 1-norm or the infinity-norm"]
    pub fn dtrcon_(
        norm: *const ::std::os::raw::c_char,
        uplo: *const ::std::os::raw::c_char,
        diag: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        a: *const f64,
        lda: *const ::std::os::raw::c_int,
        rcond: *mut f64,
        work: *mut f64,
        iwork: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
        arg3: usize,
    );
    #[doc = "DTREVC - compute some or all of the right and/or left */\n/* eigenvectors of a real upper quasi-triangular matrix T"]
    pub fn dtrevc_(
        side: *const ::std::os::raw::c_char,
        howmny: *const ::std::os::raw::c_char,
        select: *const ::std::os::raw::c_int,
        n: *const ::std::os::raw::c_int,
        t: *const f64,
        ldt: *const ::std::os::raw::c_int,
        vl: *mut f64,
        ldvl: *const ::std::os::raw::c_int,
        vr: *mut f64,
        ldvr: *const ::std::os::raw::c_int,
        mm: *const ::std::os::raw::c_int,
        m: *mut ::std::os::raw::c_int,
        work: *mut f64,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
    );
    #[doc = "DTREXC - reorder the real Schur factorization of a real matrix */\n/* A = Q*T*Q**T, so that the diagonal block of T with row index */\n/* IFST is moved to row ILST"]
    pub fn dtrexc_(
        compq: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        t: *mut f64,
        ldt: *const ::std::os::raw::c_int,
        q: *mut f64,
        ldq: *const ::std::os::raw::c_int,
        ifst: *mut ::std::os::raw::c_int,
        ILST: *mut ::std::os::raw::c_int,
        work: *mut f64,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    #[doc = "DTRRFS - provide error bounds and backward error estimates for */\n/* the solution to a system of linear equations with a triangular */\n/* coefficient matrix"]
    pub fn dtrrfs_(
        uplo: *const ::std::os::raw::c_char,
        trans: *const ::std::os::raw::c_char,
        diag: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        nrhs: *const ::std::os::raw::c_int,
        a: *const f64,
        lda: *const ::std::os::raw::c_int,
        b: *const f64,
        ldb: *const ::std::os::raw::c_int,
        x: *mut f64,
        ldx: *const ::std::os::raw::c_int,
        ferr: *mut f64,
        berr: *mut f64,
        work: *mut f64,
        iwork: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
        arg3: usize,
    );
    #[doc = "DTRSEN - reorder the real Schur factorization of a real matrix */\n/* A = Q*T*Q**T, so that a selected cluster of eigenvalues appears */\n/* in the leading diagonal blocks of the upper quasi-triangular */\n/* matrix T,"]
    pub fn dtrsen_(
        job: *const ::std::os::raw::c_char,
        compq: *const ::std::os::raw::c_char,
        select: *const ::std::os::raw::c_int,
        n: *const ::std::os::raw::c_int,
        t: *mut f64,
        ldt: *const ::std::os::raw::c_int,
        q: *mut f64,
        ldq: *const ::std::os::raw::c_int,
        wr: *mut f64,
        wi: *mut f64,
        m: *mut ::std::os::raw::c_int,
        s: *mut f64,
        sep: *mut f64,
        work: *mut f64,
        lwork: *const ::std::os::raw::c_int,
        iwork: *mut ::std::os::raw::c_int,
        liwork: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
    );
    #[doc = "DTRSNA - estimate reciprocal condition numbers for specified */\n/* eigenvalues and/or right eigenvectors of a real upper */\n/* quasi-triangular matrix T (or of any matrix Q*T*Q**T with Q */\n/* orthogonal);"]
    pub fn dtrsna_(
        job: *const ::std::os::raw::c_char,
        howmny: *const ::std::os::raw::c_char,
        select: *const ::std::os::raw::c_int,
        n: *const ::std::os::raw::c_int,
        t: *const f64,
        ldt: *const ::std::os::raw::c_int,
        vl: *const f64,
        ldvl: *const ::std::os::raw::c_int,
        vr: *const f64,
        ldvr: *const ::std::os::raw::c_int,
        s: *mut f64,
        sep: *mut f64,
        mm: *const ::std::os::raw::c_int,
        m: *mut ::std::os::raw::c_int,
        work: *mut f64,
        lwork: *const ::std::os::raw::c_int,
        iwork: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
    );
    #[doc = "DTRSYL - solve the real Sylvester matrix equation"]
    pub fn dtrsyl_(
        trana: *const ::std::os::raw::c_char,
        tranb: *const ::std::os::raw::c_char,
        isgn: *const ::std::os::raw::c_int,
        m: *const ::std::os::raw::c_int,
        n: *const ::std::os::raw::c_int,
        a: *const f64,
        lda: *const ::std::os::raw::c_int,
        b: *const f64,
        ldb: *const ::std::os::raw::c_int,
        c: *mut f64,
        ldc: *const ::std::os::raw::c_int,
        scale: *mut f64,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
    );
    #[doc = "DTRTI2 - compute the inverse of a real upper or lower */\n/* triangular matrix"]
    pub fn dtrti2_(
        uplo: *const ::std::os::raw::c_char,
        diag: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        a: *mut f64,
        lda: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
    );
    #[doc = "DTRTRI - compute the inverse of a real upper or lower */\n/* triangular matrix A"]
    pub fn dtrtri_(
        uplo: *const ::std::os::raw::c_char,
        diag: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        a: *mut f64,
        lda: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
    );
    #[doc = "DTRTRS - solve a triangular system of the form   A * X = B or */\n/* A**T * X = B"]
    pub fn dtrtrs_(
        uplo: *const ::std::os::raw::c_char,
        trans: *const ::std::os::raw::c_char,
        diag: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        nrhs: *const ::std::os::raw::c_int,
        a: *const f64,
        lda: *const ::std::os::raw::c_int,
        b: *mut f64,
        ldb: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
        arg3: usize,
    );
    #[doc = "DHGEQZ - implement a single-/double-shift version of the QZ */\n/* method for finding the generalized eigenvalues */\n/* w(j);=(ALPHAR(j); + i*ALPHAI(j););/BETAR(j); of the equation */\n/* det( A - w(i); B ); = 0  In addition, the pair A,B may be */\n/* reduced to generalized Schur form"]
    pub fn dhgeqz_(
        job: *const ::std::os::raw::c_char,
        compq: *const ::std::os::raw::c_char,
        compz: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        ILO: *const ::std::os::raw::c_int,
        IHI: *const ::std::os::raw::c_int,
        a: *mut f64,
        lda: *const ::std::os::raw::c_int,
        b: *mut f64,
        ldb: *const ::std::os::raw::c_int,
        alphar: *mut f64,
        alphai: *mut f64,
        beta: *const f64,
        q: *mut f64,
        ldq: *const ::std::os::raw::c_int,
        z: *mut f64,
        ldz: *const ::std::os::raw::c_int,
        work: *mut f64,
        lwork: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
        arg3: usize,
    );
    #[doc = "DHSEIN - use inverse iteration to find specified right and/or */\n/* left eigenvectors of a real upper Hessenberg matrix H"]
    pub fn dhsein_(
        side: *const ::std::os::raw::c_char,
        eigsrc: *const ::std::os::raw::c_char,
        initv: *const ::std::os::raw::c_char,
        select: *mut ::std::os::raw::c_int,
        n: *const ::std::os::raw::c_int,
        h: *mut f64,
        ldh: *const ::std::os::raw::c_int,
        wr: *mut f64,
        wi: *mut f64,
        vl: *mut f64,
        ldvl: *const ::std::os::raw::c_int,
        vr: *mut f64,
        ldvr: *const ::std::os::raw::c_int,
        mm: *const ::std::os::raw::c_int,
        m: *mut ::std::os::raw::c_int,
        work: *mut f64,
        ifaill: *mut ::std::os::raw::c_int,
        ifailr: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
        arg3: usize,
    );
    #[doc = "DHSEQR - compute the eigenvalues of a real upper Hessenberg */\n/* matrix H and, optionally, the matrices T and Z from the Schur */\n/* decomposition H = Z T Z**T, where T is an upper */\n/* quasi-triangular matrix (the Schur form);, and Z is the */\n/* orthogonal matrix of Schur vectors"]
    pub fn dhseqr_(
        job: *const ::std::os::raw::c_char,
        compz: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        ilo: *const ::std::os::raw::c_int,
        ihi: *const ::std::os::raw::c_int,
        h: *mut f64,
        ldh: *const ::std::os::raw::c_int,
        wr: *mut f64,
        wi: *mut f64,
        z: *mut f64,
        ldz: *const ::std::os::raw::c_int,
        work: *mut f64,
        lwork: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
    );
    #[doc = "DLABAD - take as input the values computed by SLAMCH for */\n/* underflow and overflow, and returns the square root of each of */\n/* these values if the log of LARGE is sufficiently large"]
    pub fn dlabad_(small: *mut f64, large: *mut f64);
    #[doc = "DLABRD - reduce the first NB rows and columns of a real */\n/* general m by n matrix A to upper or lower bidiagonal form by an */\n/* orthogonal transformation Q' * A * P, and returns the matrices */\n/* X and Y which are needed to apply the transformation to the */\n/* unreduced part of A"]
    pub fn dlabrd_(
        m: *const ::std::os::raw::c_int,
        n: *const ::std::os::raw::c_int,
        nb: *const ::std::os::raw::c_int,
        a: *mut f64,
        lda: *const ::std::os::raw::c_int,
        d: *mut f64,
        e: *mut f64,
        tauq: *mut f64,
        taup: *mut f64,
        x: *mut f64,
        ldx: *const ::std::os::raw::c_int,
        y: *mut f64,
        ldy: *const ::std::os::raw::c_int,
    );
    #[doc = "DLACON - estimate the 1-norm of a square, real matrix A"]
    pub fn dlacon_(
        n: *const ::std::os::raw::c_int,
        v: *mut f64,
        x: *mut f64,
        isgn: *mut ::std::os::raw::c_int,
        est: *mut f64,
        kase: *mut ::std::os::raw::c_int,
    );
    #[doc = "DLACPY - copy all or part of a two-dimensional matrix A to */\n/* another matrix B"]
    pub fn dlacpy_(
        uplo: *const ::std::os::raw::c_char,
        m: *const ::std::os::raw::c_int,
        n: *const ::std::os::raw::c_int,
        a: *const f64,
        lda: *const ::std::os::raw::c_int,
        b: *mut f64,
        ldb: *const ::std::os::raw::c_int,
        arg1: usize,
    );
    #[doc = "DLADIV - perform complex division in real arithmetic"]
    pub fn dladiv_(
        a: *const f64,
        b: *const f64,
        c: *const f64,
        d: *const f64,
        p: *mut f64,
        q: *mut f64,
    );
    #[doc = "DLAE2 - compute the eigenvalues of a 2-by-2 symmetric matrix \\[ A B \\] */\n/*\t\t\t\t\t\t\t\t\\[ B C \\]"]
    pub fn dlae2_(a: *const f64, b: *const f64, c: *const f64, rt1: *mut f64, rt2: *mut f64);
    #[doc = "DLAEBZ - contain the iteration loops which compute and use the */\n/* function N(w);, which is the count of eigenvalues of a */\n/* symmetric tridiagonal matrix T less than or equal to its */\n/* argument w"]
    pub fn dlaebz_(
        ijob: *const ::std::os::raw::c_int,
        nitmax: *const ::std::os::raw::c_int,
        n: *const ::std::os::raw::c_int,
        mmax: *const ::std::os::raw::c_int,
        minp: *const ::std::os::raw::c_int,
        nbmin: *const ::std::os::raw::c_int,
        abstol: *const f64,
        reltol: *const f64,
        pivmin: *const f64,
        d: *mut f64,
        e: *mut f64,
        e2: *mut f64,
        nval: *mut ::std::os::raw::c_int,
        ab: *mut f64,
        c: *mut f64,
        mout: *mut ::std::os::raw::c_int,
        nab: *mut ::std::os::raw::c_int,
        work: *mut f64,
        iwork: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    );
    #[doc = "DLAED0 - compute all eigenvalues and corresponding */\n/* eigenvectors of a symmetric tridiagonal matrix using the divide */\n/* and conquer method"]
    pub fn dlaed0_(
        icompq: *const ::std::os::raw::c_int,
        qsiz: *const ::std::os::raw::c_int,
        n: *const ::std::os::raw::c_int,
        d: *mut f64,
        e: *mut f64,
        q: *mut f64,
        ldq: *const ::std::os::raw::c_int,
        qstore: *mut f64,
        ldqs: *const ::std::os::raw::c_int,
        work: *mut f64,
        iwork: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    );
    #[doc = "DLAED1 - compute the updated eigensystem of a diagonal matrix */\n/* after modification by a rank-one symmetric matrix"]
    pub fn dlaed1_(
        n: *const ::std::os::raw::c_int,
        d: *mut f64,
        q: *mut f64,
        ldq: *const ::std::os::raw::c_int,
        indxq: *mut ::std::os::raw::c_int,
        rho: *const f64,
        cutpnt: *const ::std::os::raw::c_int,
        work: *mut f64,
        iwork: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    );
    #[doc = "DLAED2 - merge the two sets of eigenvalues together La_INT *o a */\n/* single sorted set"]
    pub fn dlaed2_(
        k: *const ::std::os::raw::c_int,
        n: *const ::std::os::raw::c_int,
        d: *mut f64,
        q: *mut f64,
        ldq: *const ::std::os::raw::c_int,
        indxq: *mut ::std::os::raw::c_int,
        rho: *mut f64,
        z: *mut f64,
        dlamda: *mut f64,
        w: *mut f64,
        q2: *mut f64,
        indx: *mut ::std::os::raw::c_int,
        indxc: *mut ::std::os::raw::c_int,
        indxp: *mut ::std::os::raw::c_int,
        coltyp: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    );
    #[doc = "DLAED3 - find the roots of the secular equation, as defined by */\n/* the values in double* d, W, and RHO, between KSTART and KSTOP"]
    pub fn dlaed3_(
        k: *const ::std::os::raw::c_int,
        n: *const ::std::os::raw::c_int,
        n1: *const ::std::os::raw::c_int,
        d: *mut f64,
        q: *mut f64,
        ldq: *const ::std::os::raw::c_int,
        rho: *const f64,
        dlamda: *mut f64,
        q2: *mut f64,
        indx: *mut ::std::os::raw::c_int,
        ctot: *mut ::std::os::raw::c_int,
        w: *mut f64,
        s: *mut f64,
        info: *mut ::std::os::raw::c_int,
    );
    #[doc = "DLAED4 - subroutine computes the I-th updated eigenvalue of a */\n/* symmetric rank-one modification to a diagonal matrix whose */\n/* elements are given in the array d, and that\t D(i); < D(j); for */\n/* i < j  and that RHO > 0"]
    pub fn dlaed4_(
        n: *const ::std::os::raw::c_int,
        i: *const ::std::os::raw::c_int,
        d: *const f64,
        z: *const f64,
        delta: *const f64,
        rho: *const f64,
        dlam: *mut f64,
        info: *mut ::std::os::raw::c_int,
    );
    #[doc = "DLAED5 - subroutine computes the I-th eigenvalue of a */\n/* symmetric rank-one modification of a 2-by-2 diagonal matrix */\n/* diag( D ); + RHO  The diagonal elements in the array D are */\n/* assumed to satisfy\tD(i); < D(j); for i < j"]
    pub fn dlaed5_(
        i: *const ::std::os::raw::c_int,
        d: *const f64,
        z: *const f64,
        delta: *mut f64,
        rho: *const f64,
        dlam: *mut f64,
    );
    #[doc = "DLAED6 - compute the positive or negative root (closest to the */\n/* origin); of\tz(1); z(2); z(3); f(x); = rho + --------- + */\n/* ---------- + ---------  d(1);-x d(2);-x d(3);-x  It is assumed */\n/* that\t  if ORGATI = .true"]
    pub fn dlaed6_(
        kniter: *const ::std::os::raw::c_int,
        orgati: *const ::std::os::raw::c_int,
        rho: *const f64,
        d: *const f64,
        z: *const f64,
        finit: *const f64,
        tau: *mut f64,
        info: *mut ::std::os::raw::c_int,
    );
    #[doc = "DLAED7 - compute the updated eigensystem of a diagonal matrix */\n/* after modification by a rank-one symmetric matrix"]
    pub fn dlaed7_(
        icompq: *const ::std::os::raw::c_int,
        n: *const ::std::os::raw::c_int,
        qsiz: *const ::std::os::raw::c_int,
        tlvls: *const ::std::os::raw::c_int,
        curlvl: *const ::std::os::raw::c_int,
        curpbm: *const ::std::os::raw::c_int,
        d: *mut f64,
        q: *mut f64,
        ldq: *const ::std::os::raw::c_int,
        indxq: *mut ::std::os::raw::c_int,
        rho: *const f64,
        cutpnt: *const ::std::os::raw::c_int,
        qstore: *mut f64,
        qptr: *mut f64,
        prmptr: *const ::std::os::raw::c_int,
        perm: *const ::std::os::raw::c_int,
        givptr: *const ::std::os::raw::c_int,
        givcol: *const ::std::os::raw::c_int,
        givnum: *const f64,
        work: *mut f64,
        iwork: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    );
    #[doc = "DLAED8 - merge the two sets of eigenvalues together La_INT *o a */\n/* single sorted set"]
    pub fn dlaed8_(
        icompq: *const ::std::os::raw::c_int,
        k: *const ::std::os::raw::c_int,
        n: *const ::std::os::raw::c_int,
        qsiz: *const ::std::os::raw::c_int,
        d: *mut f64,
        q: *mut f64,
        ldq: *const ::std::os::raw::c_int,
        indxq: *const ::std::os::raw::c_int,
        rho: *mut f64,
        cutpnt: *const ::std::os::raw::c_int,
        z: *const f64,
        dlamda: *mut f64,
        q2: *mut f64,
        ldq2: *const ::std::os::raw::c_int,
        w: *mut f64,
        perm: *mut ::std::os::raw::c_int,
        givptr: *mut ::std::os::raw::c_int,
        givcol: *mut ::std::os::raw::c_int,
        givnum: *mut f64,
        indxp: *mut ::std::os::raw::c_int,
        indx: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    );
    #[doc = "DLAED9 - find the roots of the secular equation, as defined by */\n/* the values in double* d, Z, and RHO, between KSTART and KSTOP"]
    pub fn dlaed9_(
        k: *const ::std::os::raw::c_int,
        kstart: *const ::std::os::raw::c_int,
        kstop: *const ::std::os::raw::c_int,
        n: *const ::std::os::raw::c_int,
        d: *mut f64,
        q: *mut f64,
        ldq: *const ::std::os::raw::c_int,
        rho: *const f64,
        dlamda: *const f64,
        w: *const f64,
        s: *mut f64,
        lds: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    );
    #[doc = "DLAEDA - compute the Z vector corresponding to the merge step */\n/* in the CURLVLth step of the merge process with TLVLS steps for */\n/* the CURPBMth problem"]
    pub fn dlaeda_(
        n: *const ::std::os::raw::c_int,
        tlvls: *const ::std::os::raw::c_int,
        curlvl: *const ::std::os::raw::c_int,
        curpbm: *const ::std::os::raw::c_int,
        prmptr: *const ::std::os::raw::c_int,
        perm: *const ::std::os::raw::c_int,
        givptr: *const ::std::os::raw::c_int,
        givcol: *const ::std::os::raw::c_int,
        givnum: *const f64,
        q: *const f64,
        qptr: *const ::std::os::raw::c_int,
        z: *mut f64,
        ztemp: *mut f64,
        info: *mut ::std::os::raw::c_int,
    );
    #[doc = "DLAEIN - use inverse iteration to find a right or left */\n/* eigenvector corresponding to the eigenvalue (WR,WI); of a real */\n/* upper Hessenberg matrix H"]
    pub fn dlaein_(
        rightv: *const ::std::os::raw::c_int,
        noinit: *const ::std::os::raw::c_int,
        n: *const ::std::os::raw::c_int,
        h: *const f64,
        ldh: *const ::std::os::raw::c_int,
        wr: *const f64,
        wi: *const f64,
        vr: *mut f64,
        vi: *mut f64,
        b: *mut f64,
        ldb: *const ::std::os::raw::c_int,
        work: *mut f64,
        eps3: *const f64,
        smlnum: *const f64,
        bignum: *const f64,
        info: *mut ::std::os::raw::c_int,
    );
    #[doc = "DLAEV2 - compute the eigendecomposition of a 2-by-2 symmetric */\n/* matrix  \\[ A B \\]  \\[ B C \\]"]
    pub fn dlaev2_(
        a: *const f64,
        b: *const f64,
        c: *const f64,
        rt1: *mut f64,
        rt2: *mut f64,
        cs1: *mut f64,
        sn1: *mut f64,
    );
    #[doc = "DLAEXC - swap adjacent diagonal blocks T11 and T22 of order 1 */\n/* or 2 in an upper quasi-triangular matrix T by an orthogonal */\n/* similarity transformation"]
    pub fn dlaexc_(
        wantq: *const ::std::os::raw::c_int,
        n: *const ::std::os::raw::c_int,
        t: *mut f64,
        ldt: *const ::std::os::raw::c_int,
        q: *mut f64,
        ldq: *const ::std::os::raw::c_int,
        j1: *const ::std::os::raw::c_int,
        n1: *const ::std::os::raw::c_int,
        n2: *const ::std::os::raw::c_int,
        work: *mut f64,
        info: *mut ::std::os::raw::c_int,
    );
    #[doc = "DLAG2 - compute the eigenvalues of a 2 x 2 generalized */\n/* eigenvalue problem A - w B, with scaling as necessary to aextern void */\n/* over-/underflow"]
    pub fn dlag2_(
        a: *const f64,
        lda: *const ::std::os::raw::c_int,
        b: *const f64,
        ldb: *const ::std::os::raw::c_int,
        safmin: *const f64,
        scale1: *mut f64,
        scale2: *mut f64,
        wr1: *mut f64,
        wr2: *mut f64,
        wi: *mut f64,
    );
    #[doc = "DLAGS2 - compute 2-by-2 orthogonal matrices U, V and Q, such */\n/* that if ( UPPER ); then   U'*A*Q = U'*( A1 A2 );*Q = ( x 0 ); */\n/* ( 0 A3 ); ( x x ); and  V'*B*Q = V'*( B1 B2 );*Q = ( x 0 );\t( */\n/* 0 B3 ); ( x x );  or if ( .NOT.UPPER ); then\t  U'*A*Q = U'*( A1 */\n/* 0 );*Q = ( x x );  ( A2 A3 ); ( 0 x ); and  V'*B*Q = V'*( B1 0 */\n/* );*Q = ( x x );  ( B2 B3 ); ( 0 x );\t The rows of the */\n/* transformed A and B are parallel, where   U = ( CSU SNU );, V = */\n/* ( CSV SNV );, Q = ( CSQ SNQ );  ( -SNU CSU ); ( -SNV CSV ); ( */\n/* -SNQ CSQ );\tZ' denotes the transpose of Z"]
    pub fn dlags2_(
        upper: *const ::std::os::raw::c_int,
        a1: *const f64,
        a2: *const f64,
        a3: *const f64,
        b1: *const f64,
        b2: *const f64,
        b3: *const f64,
        csu: *mut f64,
        snu: *mut f64,
        csv: *mut f64,
        snv: *mut f64,
        csq: *mut f64,
        snq: *mut f64,
    );
    #[doc = "DLAGTF - factorize the matrix (T - lambda*I);, where T is an n */\n/* by n tridiagonal matrix and lambda is a scalar, as\tT - */\n/* lambda*I = PLU,"]
    pub fn dlagtf_(
        n: *const ::std::os::raw::c_int,
        a: *mut f64,
        lambda: *const f64,
        b: *mut f64,
        c: *mut f64,
        tol: *const f64,
        d: *mut f64,
        in_: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    );
    #[doc = "DLAGTM - perform a matrix-vector product of the form\t  B := */\n/* alpha * A * X + beta * B  where A is a tridiagonal matrix of */\n/* order N, B and X are N by NRHS matrices, and alpha and beta are */\n/* real scalars, each of which may be 0., 1., or -1"]
    pub fn dlagtm_(
        trans: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        nrhs: *const ::std::os::raw::c_int,
        alpha: *const f64,
        dl: *const f64,
        d: *const f64,
        du: *const f64,
        x: *const f64,
        ldx: *const ::std::os::raw::c_int,
        beta: *const f64,
        b: *mut f64,
        ldb: *const ::std::os::raw::c_int,
        arg1: usize,
    );
    #[doc = "DLAGTS - may be used to solve one of the systems of equations */\n/* (T - lambda*I);*x = y or (T - lambda*I);'*x = y,"]
    pub fn dlagts_(
        job: *const ::std::os::raw::c_int,
        n: *const ::std::os::raw::c_int,
        a: *const f64,
        b: *const f64,
        c: *const f64,
        d: *const f64,
        in_: *const ::std::os::raw::c_int,
        y: *mut f64,
        tol: *mut f64,
        info: *mut ::std::os::raw::c_int,
    );
    #[doc = "DLAHQR - an auxiliary routine called by DHSEQR to update the */\n/* eigenvalues and Schur decomposition already computed by DHSEQR, */\n/* by dealing with the Hessenberg submatrix in rows and columns */\n/* ILO to IHI"]
    pub fn dlahqr_(
        wantt: *const ::std::os::raw::c_int,
        wantz: *const ::std::os::raw::c_int,
        n: *const ::std::os::raw::c_int,
        ilo: *const ::std::os::raw::c_int,
        ihi: *const ::std::os::raw::c_int,
        H: *mut f64,
        ldh: *const ::std::os::raw::c_int,
        wr: *mut f64,
        wi: *mut f64,
        iloz: *const ::std::os::raw::c_int,
        ihiz: *const ::std::os::raw::c_int,
        z: *mut f64,
        ldz: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    );
    #[doc = "DLAIC1 - apply one step of incremental condition estimation in */\n/* its simplest version"]
    pub fn dlaic1_(
        job: *const ::std::os::raw::c_int,
        j: *const ::std::os::raw::c_int,
        x: *const f64,
        sest: *const f64,
        w: *const f64,
        gamma: *const f64,
        sestpr: *mut f64,
        s: *mut f64,
        c: *mut f64,
    );
    #[doc = "DLALN2 - solve a system of the form (ca A - w D ); X = s B or */\n/* (ca A' - w D); X = s B with possible scaling (\"s\"); and */\n/* perturbation of A"]
    pub fn dlaln2_(
        ltrans: *const ::std::os::raw::c_int,
        na: *const ::std::os::raw::c_int,
        nw: *const ::std::os::raw::c_int,
        smin: *const f64,
        ca: *const f64,
        a: *const f64,
        lda: *const ::std::os::raw::c_int,
        d1: *const f64,
        d2: *const f64,
        b: *const f64,
        ldb: *const ::std::os::raw::c_int,
        wr: *const f64,
        wi: *const f64,
        x: *mut f64,
        ldx: *const ::std::os::raw::c_int,
        scale: *mut f64,
        xnorm: *mut f64,
        info: *mut ::std::os::raw::c_int,
    );
    #[doc = "DLAMCH - determine double precision machine parameters"]
    pub fn dlamch_(cmach: *const ::std::os::raw::c_char, arg1: usize) -> f64;
    #[doc = "DLAMRG - will create a permutation list which will merge the */\n/* elements of A (which is composed of two independently sorted */\n/* sets); La_INT *o a single set which is sorted in ascending order"]
    pub fn dlamrg_(
        n1: *const ::std::os::raw::c_int,
        n2: *const ::std::os::raw::c_int,
        a: *const f64,
        dtrd1: *const ::std::os::raw::c_int,
        dtrd2: *const ::std::os::raw::c_int,
        index: *mut ::std::os::raw::c_int,
    );
    #[doc = "DLANGB - return the value of the one norm, or the Frobenius */\n/* norm, or the infinity norm, or the element of largest absolute */\n/* value of an n by n band matrix A, with kl sub-diagonals and ku */\n/* super-diagonals"]
    pub fn dlangb_(
        norm: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        kl: *const ::std::os::raw::c_int,
        ku: *const ::std::os::raw::c_int,
        ab: *const f64,
        ldab: *const ::std::os::raw::c_int,
        work: *mut f64,
        arg1: usize,
    ) -> f64;
    #[doc = "DLANGE - return the value of the one norm, or the Frobenius */\n/* norm, or the infinity norm, or the element of largest absolute */\n/* value of a real matrix A"]
    pub fn dlange_(
        norm: *const ::std::os::raw::c_char,
        m: *const ::std::os::raw::c_int,
        n: *const ::std::os::raw::c_int,
        a: *const f64,
        lda: *const ::std::os::raw::c_int,
        work: *mut f64,
        arg1: usize,
    ) -> f64;
    #[doc = "DLANGT - return the value of the one norm, or the Frobenius */\n/* norm, or the infinity norm, or the element of largest absolute */\n/* value of a real tridiagonal matrix A"]
    pub fn dlangt_(
        norm: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        dl: *const f64,
        d: *const f64,
        du: *const f64,
        arg1: usize,
    ) -> f64;
    #[doc = "DLANHS - return the value of the one norm, or the Frobenius */\n/* norm, or the infinity norm, or the element of largest absolute */\n/* value of a Hessenberg matrix A"]
    pub fn dlanhs_(
        norm: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        a: *const f64,
        lda: *const ::std::os::raw::c_int,
        work: *mut f64,
        arg1: usize,
    ) -> f64;
    #[doc = "DLANSB - return the value of the one norm, or the Frobenius */\n/* norm, or the infinity norm, or the element of largest absolute */\n/* value of an n by n symmetric band matrix A, with k */\n/* super-diagonals"]
    pub fn dlansb_(
        norm: *const ::std::os::raw::c_char,
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        k: *const ::std::os::raw::c_int,
        ab: *const f64,
        ldab: *const ::std::os::raw::c_int,
        work: *mut f64,
        arg1: usize,
        arg2: usize,
    ) -> f64;
    #[doc = "DLANSP - return the value of the one norm, or the Frobenius */\n/* norm, or the infinity norm, or the element of largest absolute */\n/* value of a real symmetric matrix A, supplied in packed form"]
    pub fn dlansp_(
        norm: *const ::std::os::raw::c_char,
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        ap: *const f64,
        work: *mut f64,
        arg1: usize,
        arg2: usize,
    ) -> f64;
    #[doc = "DLANST - return the value of the one norm, or the Frobenius */\n/* norm, or the infinity norm, or the element of largest absolute */\n/* value of a real symmetric tridiagonal matrix A"]
    pub fn dlanst_(
        norm: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        d: *const f64,
        e: *const f64,
        arg1: usize,
    ) -> f64;
    #[doc = "DLANSY - return the value of the one norm, or the Frobenius */\n/* norm, or the infinity norm, or the element of largest absolute */\n/* value of a real symmetric matrix A"]
    pub fn dlansy_(
        norm: *const ::std::os::raw::c_char,
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        a: *const f64,
        lda: *const ::std::os::raw::c_int,
        work: *mut f64,
        arg1: usize,
        arg2: usize,
    ) -> f64;
    #[doc = "DLANTB - return the value of the one norm, or the Frobenius */\n/* norm, or the infinity norm, or the element of largest absolute */\n/* value of an n by n triangular band matrix A, with ( k + 1 ) diagonals"]
    pub fn dlantb_(
        norm: *const ::std::os::raw::c_char,
        uplo: *const ::std::os::raw::c_char,
        diag: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        k: *const ::std::os::raw::c_int,
        ab: *const f64,
        ldab: *const ::std::os::raw::c_int,
        work: *mut f64,
        arg1: usize,
        arg2: usize,
        arg3: usize,
    ) -> f64;
    #[doc = "DLANTP - return the value of the one norm, or the Frobenius */\n/* norm, or the infinity norm, or the element of largest absolute */\n/* value of a triangular matrix A, supplied in packed form"]
    pub fn dlantp_(
        norm: *const ::std::os::raw::c_char,
        uplo: *const ::std::os::raw::c_char,
        diag: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        ap: *const f64,
        work: *mut f64,
        arg1: usize,
        arg2: usize,
        arg3: usize,
    ) -> f64;
    #[doc = "DLANTR - return the value of the one norm, or the Frobenius */\n/* norm, or the infinity norm, or the element of largest absolute */\n/* value of a trapezoidal or triangular matrix A"]
    pub fn dlantr_(
        norm: *const ::std::os::raw::c_char,
        uplo: *const ::std::os::raw::c_char,
        diag: *const ::std::os::raw::c_char,
        m: *const ::std::os::raw::c_int,
        n: *const ::std::os::raw::c_int,
        a: *const f64,
        lda: *const ::std::os::raw::c_int,
        work: *mut f64,
        arg1: usize,
        arg2: usize,
        arg3: usize,
    ) -> f64;
    #[doc = "DLANV2 - compute the Schur factorization of a real 2-by-2 */\n/* nonsymmetric matrix in standard form"]
    pub fn dlanv2_(
        a: *mut f64,
        b: *mut f64,
        c: *mut f64,
        d: *mut f64,
        rt1r: *mut f64,
        rt1i: *mut f64,
        rt2r: *mut f64,
        rt2i: *mut f64,
        cs: *mut f64,
        sn: *mut f64,
    );
    #[doc = "DLAPLL - two column vectors X and Y, let A = ( X Y );"]
    pub fn dlapll_(
        n: *const ::std::os::raw::c_int,
        x: *mut f64,
        incx: *const ::std::os::raw::c_int,
        y: *mut f64,
        incy: *const ::std::os::raw::c_int,
        ssmin: *mut f64,
    );
    #[doc = "DLAPMT - rearrange the columns of the M by N matrix X as */\n/* specified by the permutation K(1);,K(2);,...,K(N); of the */\n/* La_INT *egers 1,...,N"]
    pub fn dlapmt_(
        forwrd: *const ::std::os::raw::c_int,
        m: *const ::std::os::raw::c_int,
        n: *const ::std::os::raw::c_int,
        x: *mut f64,
        ldx: *const ::std::os::raw::c_int,
        k: *const ::std::os::raw::c_int,
    );
    #[doc = "DLAPY2 - return sqrt(x**2+y**2);, taking care not to cause */\n/* unnecessary overflow"]
    pub fn dlapy2_(x: *const f64, y: *const f64) -> f64;
    #[doc = "DLAPY3 - return sqrt(x**2+y**2+z**2);, taking care not to */\n/* cause unnecessary overflow"]
    pub fn dlapy3_(x: *const f64, y: *const f64, z: *const f64) -> f64;
    #[doc = "DLAQGB - equilibrate a general M by N band matrix A with KL */\n/* subdiagonals and KU superdiagonals using the row and scaling */\n/* factors in the vectors R and C"]
    pub fn dlaqgb_(
        m: *const ::std::os::raw::c_int,
        n: *const ::std::os::raw::c_int,
        kl: *const ::std::os::raw::c_int,
        ku: *const ::std::os::raw::c_int,
        ab: *mut f64,
        ldab: *const ::std::os::raw::c_int,
        r: *mut f64,
        c: *mut f64,
        rowcnd: *mut f64,
        colcnd: *mut f64,
        amax: *const f64,
        equed: *const ::std::os::raw::c_char,
        arg1: usize,
    );
    #[doc = "DLAQGE - equilibrate a general M by N matrix A using the row */\n/* and scaling factors in the vectors R and C"]
    pub fn dlaqge_(
        m: *const ::std::os::raw::c_int,
        n: *const ::std::os::raw::c_int,
        a: *mut f64,
        lda: *const ::std::os::raw::c_int,
        r: *mut f64,
        c: *mut f64,
        rowcnd: *mut f64,
        colcnd: *mut f64,
        amax: *const f64,
        equed: *const ::std::os::raw::c_char,
        arg1: usize,
    );
    #[doc = "DLAQSB - equilibrate a symmetric band matrix A using the */\n/* scaling factors in the vector S"]
    pub fn dlaqsb_(
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        kd: *const ::std::os::raw::c_int,
        ab: *mut f64,
        ldab: *const ::std::os::raw::c_int,
        s: *const f64,
        scond: *const f64,
        amax: *const f64,
        equed: *const ::std::os::raw::c_char,
        arg1: usize,
        arg2: usize,
    );
    #[doc = "DLAQSP - equilibrate a symmetric matrix A using the scaling */\n/* factors in the vector S"]
    pub fn dlaqsp_(
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        ap: *mut f64,
        s: *const f64,
        scond: *const f64,
        amax: *const f64,
        equed: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    #[doc = "DLAQSY - equilibrate a symmetric matrix A using the scaling */\n/* factors in the vector S"]
    pub fn dlaqsy_(
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        a: *mut f64,
        lda: *const ::std::os::raw::c_int,
        s: *const f64,
        scond: *const f64,
        amax: *const f64,
        equed: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    #[doc = "DLAQTR - solve the real quasi-triangular system   */\n/* op(T) * p = scale*c"]
    pub fn dlaqtr_(
        ltran: *const ::std::os::raw::c_int,
        lreal: *const ::std::os::raw::c_int,
        n: *const ::std::os::raw::c_int,
        t: *const f64,
        ldt: *const ::std::os::raw::c_int,
        b: *const f64,
        w: *const f64,
        scale: *mut f64,
        x: *mut f64,
        work: *mut f64,
        info: *mut ::std::os::raw::c_int,
    );
    #[doc = "DLAR2V - apply a vector of real plane rotations from both */\n/* sides to a sequence of 2-by-2 real symmetric matrices, defined */\n/* by the elements of the vectors x, y and z"]
    pub fn dlar2v_(
        n: *const ::std::os::raw::c_int,
        x: *mut f64,
        y: *mut f64,
        z: *mut f64,
        incx: *const ::std::os::raw::c_int,
        c: *const f64,
        s: *const f64,
        incc: *const ::std::os::raw::c_int,
    );
    #[doc = "DLARF - apply a real elementary reflector H to a real m by n */\n/* matrix C, from either the left or the right"]
    pub fn dlarf_(
        side: *const ::std::os::raw::c_char,
        m: *const ::std::os::raw::c_int,
        n: *const ::std::os::raw::c_int,
        v: *const f64,
        incv: *const ::std::os::raw::c_int,
        tau: *const f64,
        c: *mut f64,
        ldc: *const ::std::os::raw::c_int,
        work: *mut f64,
        arg1: usize,
    );
    #[doc = "DLARFB - apply a real block reflector H or its transpose H' */\n/* to a real m by n matrix C, from either the left or the right"]
    pub fn dlarfb_(
        side: *const ::std::os::raw::c_char,
        trans: *const ::std::os::raw::c_char,
        direct: *const ::std::os::raw::c_char,
        storev: *const ::std::os::raw::c_char,
        m: *const ::std::os::raw::c_int,
        n: *const ::std::os::raw::c_int,
        k: *const ::std::os::raw::c_int,
        v: *const f64,
        ldv: *const ::std::os::raw::c_int,
        t: *const f64,
        ldt: *const ::std::os::raw::c_int,
        c: *mut f64,
        ldc: *const ::std::os::raw::c_int,
        work: *mut f64,
        lwork: *const ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
        arg3: usize,
        arg4: usize,
    );
    #[doc = "DLARFG - generate a real elementary reflector H of order n, */\n/* such that   H * ( alpha ) = ( beta ), H' * H = I"]
    pub fn dlarfg_(
        n: *const ::std::os::raw::c_int,
        alpha: *const f64,
        x: *mut f64,
        incx: *const ::std::os::raw::c_int,
        tau: *mut f64,
    );
    #[doc = "DLARFT - form the triangular factor T of a real block */\n/* reflector H of order n, which is defined as a product of k */\n/* elementary reflectors"]
    pub fn dlarft_(
        direct: *const ::std::os::raw::c_char,
        storev: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        k: *const ::std::os::raw::c_int,
        v: *mut f64,
        ldv: *const ::std::os::raw::c_int,
        tau: *const f64,
        t: *mut f64,
        ldt: *const ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
    );
    #[doc = "DLARFX - apply a real elementary reflector H to a real m by n */\n/* matrix C, from either the left or the right"]
    pub fn dlarfx_(
        side: *const ::std::os::raw::c_char,
        m: *const ::std::os::raw::c_int,
        n: *const ::std::os::raw::c_int,
        v: *const f64,
        tau: *const f64,
        c: *mut f64,
        ldc: *const ::std::os::raw::c_int,
        work: *mut f64,
        arg1: usize,
    );
    #[doc = "DLARGV - generate a vector of real plane rotations, determined */\n/* by elements of the real vectors x and y"]
    pub fn dlargv_(
        n: *const ::std::os::raw::c_int,
        x: *mut f64,
        incx: *const ::std::os::raw::c_int,
        y: *mut f64,
        incy: *const ::std::os::raw::c_int,
        c: *mut f64,
        incc: *const ::std::os::raw::c_int,
    );
    #[doc = "DLARNV - return a vector of n random real numbers from a */\n/* uniform or normal distribution"]
    pub fn dlarnv_(
        idist: *const ::std::os::raw::c_int,
        iseed: *mut ::std::os::raw::c_int,
        n: *const ::std::os::raw::c_int,
        x: *mut f64,
    );
    #[doc = "DLARTG - generate a plane rotation so that\t\\[ CS SN \\]"]
    pub fn dlartg_(f: *const f64, g: *const f64, cs: *mut f64, sn: *mut f64, r: *mut f64);
    #[doc = "DLARTV - apply a vector of real plane rotations to elements of */\n/* the real vectors x and y"]
    pub fn dlartv_(
        n: *const ::std::os::raw::c_int,
        x: *mut f64,
        incx: *const ::std::os::raw::c_int,
        y: *mut f64,
        incy: *const ::std::os::raw::c_int,
        c: *const f64,
        s: *const f64,
        incc: *const ::std::os::raw::c_int,
    );
    #[doc = "DLARUV - return a vector of n random real numbers from a */\n/* uniform (0,1);"]
    pub fn dlaruv_(iseed: *mut ::std::os::raw::c_int, n: *const ::std::os::raw::c_int, x: *mut f64);
    #[doc = "DLAS2 - compute the singular values of the 2-by-2 matrix */\n/* \\[ F G \\]  \\[ 0 H \\]"]
    pub fn dlas2_(f: *const f64, g: *const f64, h: *const f64, ssmin: *mut f64, ssmax: *mut f64);
    #[doc = "DLASCL - multiply the M by N real matrix A by the real scalar */\n/* CTO/CFROM"]
    pub fn dlascl_(
        type_: *const ::std::os::raw::c_char,
        kl: *const ::std::os::raw::c_int,
        ku: *const ::std::os::raw::c_int,
        cfrom: *mut f64,
        cto: *mut f64,
        m: *const ::std::os::raw::c_int,
        n: *const ::std::os::raw::c_int,
        a: *mut f64,
        lda: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    #[doc = "DLASET - initialize an m-by-n matrix A to BETA on the diagonal */\n/* and ALPHA on the offdiagonals"]
    pub fn dlaset_(
        uplo: *const ::std::os::raw::c_char,
        m: *const ::std::os::raw::c_int,
        n: *const ::std::os::raw::c_int,
        alpha: *const f64,
        beta: *const f64,
        a: *mut f64,
        lda: *const ::std::os::raw::c_int,
        arg1: usize,
    );
    #[doc = "DLASQ1 - DLASQ1 computes the singular values of a real N-by-N */\n/* bidiagonal  matrix with diagonal D and off-diagonal E"]
    pub fn dlasq1_(
        n: *const ::std::os::raw::c_int,
        d: *mut f64,
        e: *mut f64,
        work: *mut f64,
        info: *mut ::std::os::raw::c_int,
    );
    #[doc = "DLASQ2 - DLASQ2 computes the singular values of a real N-by-N */\n/* unreduced  bidiagonal matrix with squared diagonal elements in */\n/* Q and  squared off-diagonal elements in E"]
    pub fn dlasq2_(
        m: *const ::std::os::raw::c_int,
        q: *mut f64,
        e: *mut f64,
        qq: *mut f64,
        ee: *mut f64,
        eps: *const f64,
        tol2: *const f64,
        small2: *const f64,
        sup: *mut f64,
        kend: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    );
    #[doc = "DLASQ3 - DLASQ3 is the workhorse of the whole bidiagonal SVD */\n/* algorithm"]
    pub fn dlasq3_(
        n: *mut ::std::os::raw::c_int,
        q: *mut f64,
        e: *mut f64,
        qq: *mut f64,
        ee: *mut f64,
        sup: *mut f64,
        sigma: *mut f64,
        kend: *mut ::std::os::raw::c_int,
        off: *mut ::std::os::raw::c_int,
        iphase: *mut ::std::os::raw::c_int,
        iconv: *const ::std::os::raw::c_int,
        eps: *const f64,
        tol2: *const f64,
        small2: *const f64,
    );
    #[doc = "DLASQ4 - DLASQ4 estimates TAU, the smallest eigenvalue of a */\n/* matrix"]
    pub fn dlasq4_(
        n: *const ::std::os::raw::c_int,
        q: *const f64,
        e: *const f64,
        tau: *mut f64,
        sup: *mut f64,
    );
    #[doc = "DLASR - perform the transformation\tA := P*A, when SIDE = 'L' */\n/* or 'l' ( Left-hand side );\tA := A*P', when SIDE = 'R' or 'r' */\n/* ( Right-hand side );\t where A is an m by n real matrix and P is */\n/* an orthogonal matrix,"]
    pub fn dlasr_(
        side: *const ::std::os::raw::c_char,
        pivot: *const ::std::os::raw::c_char,
        direct: *const ::std::os::raw::c_char,
        m: *const ::std::os::raw::c_int,
        n: *const ::std::os::raw::c_int,
        c: *const f64,
        s: *const f64,
        a: *mut f64,
        lda: *const ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
        arg3: usize,
    );
    #[doc = "DLASRT - the numbers in D in increasing order (if ID = 'I'); */\n/* or in decreasing order (if ID = 'D' );"]
    pub fn dlasrt_(
        id: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        d: *mut f64,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    #[doc = "DLASSQ - return the values scl and smsq such that   ( scl**2 */\n/* );*smsq = x( 1 );**2 +...+ x( n );**2 + ( scale**2 );*sumsq,"]
    pub fn dlassq_(
        n: *const ::std::os::raw::c_int,
        x: *const f64,
        incx: *const ::std::os::raw::c_int,
        scale: *mut f64,
        sumsq: *mut f64,
    );
    #[doc = "DLASV2 - compute the singular value decomposition of a 2-by-2 */\n/* triangular matrix  \\[ F G \\]  \\[ 0 H \\]"]
    pub fn dlasv2_(
        f: *const f64,
        g: *const f64,
        h: *const f64,
        ssmin: *mut f64,
        ssmax: *mut f64,
        snr: *mut f64,
        csr: *mut f64,
        snl: *mut f64,
        csl: *mut f64,
    );
    #[doc = "DLASWP - perform a series of row La_INT *erchanges on the matrix A"]
    pub fn dlaswp_(
        n: *const ::std::os::raw::c_int,
        a: *mut f64,
        lda: *const ::std::os::raw::c_int,
        k1: *const ::std::os::raw::c_int,
        k2: *const ::std::os::raw::c_int,
        ipiv: *const ::std::os::raw::c_int,
        incx: *const ::std::os::raw::c_int,
    );
    #[doc = "DLASY2 - solve for the N1 by N2 matrix double* x, 1 <= N1,N2 <= 2, in */\n/* op(TL);*X + ISGN*X*op(TR); = SCALE*B,"]
    pub fn dlasy2_(
        ltranl: *const ::std::os::raw::c_int,
        ltranr: *const ::std::os::raw::c_int,
        isgn: *const ::std::os::raw::c_int,
        n1: *const ::std::os::raw::c_int,
        n2: *const ::std::os::raw::c_int,
        tl: *const f64,
        ldtl: *const ::std::os::raw::c_int,
        tr: *const f64,
        ldtr: *const ::std::os::raw::c_int,
        b: *const f64,
        ldb: *const ::std::os::raw::c_int,
        scale: *mut f64,
        x: *mut f64,
        ldx: *const ::std::os::raw::c_int,
        xnorm: *mut f64,
        info: *mut ::std::os::raw::c_int,
    );
    #[doc = "DLASYF - compute a partial factorization of a real symmetric */\n/* matrix A using the Bunch-Kaufman diagonal pivoting method"]
    pub fn dlasyf_(
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        nb: *const ::std::os::raw::c_int,
        kb: *const ::std::os::raw::c_int,
        a: *mut f64,
        lda: *const ::std::os::raw::c_int,
        ipiv: *mut ::std::os::raw::c_int,
        w: *mut f64,
        ldw: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    #[doc = "DLATBS - solve one of the triangular systems\t  A *x = s*b or */\n/* A'*x = s*b  with scaling to prevent overflow, where A is an */\n/* upper or lower triangular band matrix"]
    pub fn dlatbs_(
        uplo: *const ::std::os::raw::c_char,
        trans: *const ::std::os::raw::c_char,
        diag: *const ::std::os::raw::c_char,
        normin: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        kd: *const ::std::os::raw::c_int,
        ab: *const f64,
        ldab: *const ::std::os::raw::c_int,
        x: *mut f64,
        scale: *mut f64,
        cnorm: *mut f64,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
        arg3: usize,
        arg4: usize,
    );
    #[doc = "DLATPS - solve one of the triangular systems\t  A *x = s*b or */\n/* A'*x = s*b  with scaling to prevent overflow, where A is an */\n/* upper or lower triangular matrix stored in packed form"]
    pub fn dlatps_(
        uplo: *const ::std::os::raw::c_char,
        trans: *const ::std::os::raw::c_char,
        diag: *const ::std::os::raw::c_char,
        normin: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        ap: *const f64,
        x: *mut f64,
        scale: *mut f64,
        cnorm: *mut f64,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
        arg3: usize,
        arg4: usize,
    );
    #[doc = "DLATRD - reduce NB rows and columns of a real symmetric matrix */\n/* A to symmetric tridiagonal form by an orthogonal similarity */\n/* transformation Q' * A * Q, and returns the matrices V and W */\n/* which are needed to apply the transformation to the unreduced */\n/* part of A"]
    pub fn dlatrd_(
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        nb: *const ::std::os::raw::c_int,
        a: *mut f64,
        lda: *const ::std::os::raw::c_int,
        e: *mut f64,
        tau: *mut f64,
        w: *mut f64,
        ldw: *const ::std::os::raw::c_int,
        arg1: usize,
    );
    #[doc = "DLATRS - solve one of the triangular systems\t  A *x = s*b or */\n/* A'*x = s*b  with scaling to prevent overflow"]
    pub fn dlatrs_(
        uplo: *const ::std::os::raw::c_char,
        trans: *const ::std::os::raw::c_char,
        diag: *const ::std::os::raw::c_char,
        normin: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        a: *const f64,
        lda: *const ::std::os::raw::c_int,
        x: *mut f64,
        scale: *mut f64,
        cnorm: *mut f64,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
        arg3: usize,
        arg4: usize,
    );
    #[doc = "DLAUU2 - compute the product U * U' or L' * const La_INT* l, where the */\n/* triangular factor U or L is stored in the upper or lower */\n/* triangular part of the array A"]
    pub fn dlauu2_(
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        a: *mut f64,
        lda: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    #[doc = "DLAUUM - compute the product U * U' or L' * L, where the */\n/* triangular factor U or L is stored in the upper or lower */\n/* triangular part of the array A"]
    pub fn dlauum_(
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        a: *mut f64,
        lda: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    #[doc = "IZMAX1 finds the index of the element whose real part has maximum\n absolute value. Returns Fortran INTEGER."]
    pub fn izmax1_(
        n: *const ::std::os::raw::c_int,
        cx: *mut Rcomplex,
        incx: *const ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_int;
    #[doc = "ZGECON estimates the reciprocal of the condition number of a general\n  complex matrix A, in either the 1-norm or the infinity-norm, using\n  the LU factorization computed by ZGETRF."]
    pub fn zgecon_(
        norm: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        a: *const Rcomplex,
        lda: *const ::std::os::raw::c_int,
        anorm: *const f64,
        rcond: *mut f64,
        work: *mut Rcomplex,
        rwork: *mut f64,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    #[doc = "ZGESV computes the solution to a complex system of linear equations"]
    pub fn zgesv_(
        n: *const ::std::os::raw::c_int,
        nrhs: *const ::std::os::raw::c_int,
        a: *mut Rcomplex,
        lda: *const ::std::os::raw::c_int,
        ipiv: *mut ::std::os::raw::c_int,
        b: *mut Rcomplex,
        ldb: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    );
    #[doc = "ZGEQP3 computes a QR factorization with column pivoting"]
    pub fn zgeqp3_(
        m: *const ::std::os::raw::c_int,
        n: *const ::std::os::raw::c_int,
        a: *mut Rcomplex,
        lda: *const ::std::os::raw::c_int,
        jpvt: *mut ::std::os::raw::c_int,
        tau: *mut Rcomplex,
        work: *mut Rcomplex,
        lwork: *const ::std::os::raw::c_int,
        rwork: *mut f64,
        info: *mut ::std::os::raw::c_int,
    );
    #[doc = "ZUNMQR applies Q or Q**H from the Left or Right"]
    pub fn zunmqr_(
        side: *const ::std::os::raw::c_char,
        trans: *const ::std::os::raw::c_char,
        m: *const ::std::os::raw::c_int,
        n: *const ::std::os::raw::c_int,
        k: *const ::std::os::raw::c_int,
        a: *mut Rcomplex,
        lda: *const ::std::os::raw::c_int,
        tau: *mut Rcomplex,
        c: *mut Rcomplex,
        ldc: *const ::std::os::raw::c_int,
        work: *mut Rcomplex,
        lwork: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
    );
    #[doc = "ZTRTRS solves triangular systems"]
    pub fn ztrtrs_(
        uplo: *const ::std::os::raw::c_char,
        trans: *const ::std::os::raw::c_char,
        diag: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        nrhs: *const ::std::os::raw::c_int,
        a: *mut Rcomplex,
        lda: *const ::std::os::raw::c_int,
        b: *mut Rcomplex,
        ldb: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
        arg3: usize,
    );
    #[doc = "ZGESVD - compute the singular value decomposition (SVD); of a   */\n/* real M-by-N matrix A, optionally computing the left and/or\t   */\n/* right singular vectors"]
    pub fn zgesvd_(
        jobu: *const ::std::os::raw::c_char,
        jobvt: *const ::std::os::raw::c_char,
        m: *const ::std::os::raw::c_int,
        n: *const ::std::os::raw::c_int,
        a: *mut Rcomplex,
        lda: *const ::std::os::raw::c_int,
        s: *mut f64,
        u: *mut Rcomplex,
        ldu: *const ::std::os::raw::c_int,
        vt: *mut Rcomplex,
        ldvt: *const ::std::os::raw::c_int,
        work: *mut Rcomplex,
        lwork: *const ::std::os::raw::c_int,
        rwork: *mut f64,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
    );
    #[doc = "ZGHEEV - compute all eigenvalues and, optionally, eigenvectors */\n/* of a Hermitian matrix A"]
    pub fn zheev_(
        jobz: *const ::std::os::raw::c_char,
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        a: *mut Rcomplex,
        lda: *const ::std::os::raw::c_int,
        w: *mut f64,
        work: *mut Rcomplex,
        lwork: *const ::std::os::raw::c_int,
        rwork: *mut f64,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
    );
    #[doc = "ZGGEEV - compute all eigenvalues and, optionally, eigenvectors */\n/* of a complex non-symmetric matrix A"]
    pub fn zgeev_(
        jobvl: *const ::std::os::raw::c_char,
        jobvr: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        a: *mut Rcomplex,
        lda: *const ::std::os::raw::c_int,
        wr: *mut Rcomplex,
        vl: *mut Rcomplex,
        ldvl: *const ::std::os::raw::c_int,
        vr: *mut Rcomplex,
        ldvr: *const ::std::os::raw::c_int,
        work: *mut Rcomplex,
        lwork: *const ::std::os::raw::c_int,
        rwork: *mut f64,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
    );
    #[doc = "ZLACN2 estimates the 1-norm of a square, complex matrix A.\n  Reverse communication is used for evaluating matrix-vector products.\n Added in R 2.7.0"]
    pub fn zlacn2_(
        n: *const ::std::os::raw::c_int,
        v: *mut Rcomplex,
        x: *mut Rcomplex,
        est: *mut f64,
        kase: *mut ::std::os::raw::c_int,
        isave: *mut ::std::os::raw::c_int,
    );
    #[doc = "ZLANSP estimates the 1-norm of a square, complex matrix A.\n  Reverse communication is used for evaluating matrix-vector products.\n Added in R 4.4.0"]
    pub fn zlansp_(
        norm: *const ::std::os::raw::c_char,
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        ap: *mut Rcomplex,
        work: *mut f64,
        arg1: usize,
        arg2: usize,
    ) -> f64;
    pub fn zlansy_(
        norm: *const ::std::os::raw::c_char,
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        a: *mut Rcomplex,
        lda: *const ::std::os::raw::c_int,
        work: *mut f64,
        arg1: usize,
        arg2: usize,
    ) -> f64;
    #[doc = "ZLANTR  -  return the value of the one norm, or the Frobenius norm,\n or the infinity norm, or the element of largest absolute value of\n a trapezoidal or triangular matrix A.\n Added in R 2.7.0"]
    pub fn zlantr_(
        norm: *const ::std::os::raw::c_char,
        uplo: *const ::std::os::raw::c_char,
        diag: *const ::std::os::raw::c_char,
        m: *const ::std::os::raw::c_int,
        n: *const ::std::os::raw::c_int,
        a: *mut Rcomplex,
        lda: *const ::std::os::raw::c_int,
        work: *mut f64,
        arg1: usize,
        arg2: usize,
        arg3: usize,
    ) -> f64;
    #[doc = "DZSUM1 - take the sum of the absolute values of a complex\n vector and returns a double precision result\n Added in R 2.15.2"]
    pub fn dzsum1_(
        n: *const ::std::os::raw::c_int,
        CX: *mut Rcomplex,
        incx: *const ::std::os::raw::c_int,
    ) -> f64;
    #[doc = "Added in R 3.6.2, 4.4.0 -- now alphabetically"]
    pub fn zpotrf_(
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        a: *mut Rcomplex,
        lda: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    pub fn zpotrf2_(
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        a: *mut Rcomplex,
        lda: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    pub fn zpotri_(
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        a: *mut Rcomplex,
        lda: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    pub fn zpotrs_(
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        nrhs: *const ::std::os::raw::c_int,
        a: *const Rcomplex,
        lda: *const ::std::os::raw::c_int,
        b: *mut Rcomplex,
        ldb: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    pub fn zppcon_(
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        ap: *const Rcomplex,
        anorm: *const f64,
        rcond: *mut f64,
        work: *mut Rcomplex,
        rwork: *mut f64,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    pub fn zpptrf_(
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        ap: *mut Rcomplex,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    pub fn zpptri_(
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        ap: *mut Rcomplex,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    pub fn zpptrs_(
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        nrhs: *const ::std::os::raw::c_int,
        a: *const Rcomplex,
        b: *mut Rcomplex,
        ldb: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    pub fn zpstrf_(
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        a: *mut Rcomplex,
        lda: *const ::std::os::raw::c_int,
        ipiv: *mut ::std::os::raw::c_int,
        rank: *mut ::std::os::raw::c_int,
        tol: *const f64,
        work: *mut f64,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    #[doc = "* Other double precision and double complex Lapack routines provided by libRlapack.\n*\nThese are extracted from the CLAPACK headers.\n*/"]
    pub fn dbdsdc_(
        uplo: *const ::std::os::raw::c_char,
        compq: *const ::std::os::raw::c_char,
        n: *mut ::std::os::raw::c_int,
        d: *mut f64,
        e: *mut f64,
        u: *mut f64,
        ldu: *mut ::std::os::raw::c_int,
        vt: *mut f64,
        ldvt: *mut ::std::os::raw::c_int,
        q: *mut f64,
        iq: *mut ::std::os::raw::c_int,
        work: *mut f64,
        iwork: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
    );
    pub fn dgelsd_(
        m: *mut ::std::os::raw::c_int,
        n: *mut ::std::os::raw::c_int,
        nrhs: *mut ::std::os::raw::c_int,
        a: *mut f64,
        lda: *mut ::std::os::raw::c_int,
        b: *mut f64,
        ldb: *mut ::std::os::raw::c_int,
        s: *mut f64,
        rcond: *mut f64,
        rank: *mut ::std::os::raw::c_int,
        work: *mut f64,
        lwork: *mut ::std::os::raw::c_int,
        iwork: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    );
    pub fn dgesc2_(
        n: *mut ::std::os::raw::c_int,
        a: *mut f64,
        lda: *mut ::std::os::raw::c_int,
        rhs: *mut f64,
        ipiv: *mut ::std::os::raw::c_int,
        jpiv: *mut ::std::os::raw::c_int,
        scale: *mut f64,
    );
    #[doc = "DGESDD - compute the singular value decomposition (SVD); of a   */\n/* real M-by-N matrix A, optionally computing the left and/or\t   */\n/* right singular vectors.  If singular vectors are desired, it uses a */\n/* divide-and-conquer algorithm."]
    pub fn dgesdd_(
        jobz: *const ::std::os::raw::c_char,
        m: *const ::std::os::raw::c_int,
        n: *const ::std::os::raw::c_int,
        a: *mut f64,
        lda: *const ::std::os::raw::c_int,
        s: *mut f64,
        u: *mut f64,
        ldu: *const ::std::os::raw::c_int,
        vt: *mut f64,
        ldvt: *const ::std::os::raw::c_int,
        work: *mut f64,
        lwork: *const ::std::os::raw::c_int,
        iwork: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    pub fn dgetc2_(
        n: *mut ::std::os::raw::c_int,
        a: *mut f64,
        lda: *mut ::std::os::raw::c_int,
        ipiv: *mut *mut ::std::os::raw::c_int,
        jpiv: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    );
    pub fn dggesx_(
        jobvsl: *const ::std::os::raw::c_char,
        jobvsr: *const ::std::os::raw::c_char,
        sort: *const ::std::os::raw::c_char,
        delctg: L_fp,
        sense: *const ::std::os::raw::c_char,
        n: *mut ::std::os::raw::c_int,
        a: *mut f64,
        lda: *mut ::std::os::raw::c_int,
        b: *mut f64,
        ldb: *mut ::std::os::raw::c_int,
        sdim: *mut ::std::os::raw::c_int,
        alphar: *mut f64,
        alphai: *mut f64,
        beta: *mut f64,
        vsl: *mut f64,
        ldvsl: *mut ::std::os::raw::c_int,
        vsr: *mut f64,
        ldvsr: *mut ::std::os::raw::c_int,
        rconde: *mut f64,
        rcondv: *mut f64,
        work: *mut f64,
        lwork: *mut ::std::os::raw::c_int,
        iwork: *mut ::std::os::raw::c_int,
        liwork: *mut ::std::os::raw::c_int,
        bwork: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
        arg3: usize,
        arg4: usize,
    );
    pub fn dggev_(
        jobvl: *const ::std::os::raw::c_char,
        jobvr: *const ::std::os::raw::c_char,
        n: *mut ::std::os::raw::c_int,
        a: *mut f64,
        lda: *mut ::std::os::raw::c_int,
        b: *mut f64,
        ldb: *mut ::std::os::raw::c_int,
        alphar: *mut f64,
        alphai: *mut f64,
        beta: *mut f64,
        vl: *mut f64,
        ldvl: *mut ::std::os::raw::c_int,
        vr: *mut f64,
        ldvr: *mut ::std::os::raw::c_int,
        work: *mut f64,
        lwork: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
    );
    pub fn dggevx_(
        balanc: *const ::std::os::raw::c_char,
        jobvl: *const ::std::os::raw::c_char,
        jobvr: *const ::std::os::raw::c_char,
        sense: *const ::std::os::raw::c_char,
        n: *mut ::std::os::raw::c_int,
        a: *mut f64,
        lda: *mut ::std::os::raw::c_int,
        b: *mut f64,
        ldb: *mut ::std::os::raw::c_int,
        alphar: *mut f64,
        alphai: *mut f64,
        beta: *mut f64,
        vl: *mut f64,
        ldvl: *mut ::std::os::raw::c_int,
        vr: *mut f64,
        ldvr: *mut ::std::os::raw::c_int,
        ilo: *mut ::std::os::raw::c_int,
        ihi: *mut ::std::os::raw::c_int,
        lscale: *mut f64,
        rscale: *mut f64,
        abnrm: *mut f64,
        bbnrm: *mut f64,
        rconde: *mut f64,
        rcondv: *mut f64,
        work: *mut f64,
        lwork: *mut ::std::os::raw::c_int,
        iwork: *mut ::std::os::raw::c_int,
        bwork: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
        arg3: usize,
        arg4: usize,
    );
    pub fn dgtts2_(
        itrans: *mut ::std::os::raw::c_int,
        n: *mut ::std::os::raw::c_int,
        nrhs: *mut ::std::os::raw::c_int,
        dl: *mut f64,
        d: *mut f64,
        du: *mut f64,
        du2: *mut f64,
        ipiv: *mut ::std::os::raw::c_int,
        b: *mut f64,
        ldb: *mut ::std::os::raw::c_int,
    );
    pub fn dlagv2_(
        a: *mut f64,
        lda: *mut ::std::os::raw::c_int,
        b: *mut f64,
        ldb: *mut ::std::os::raw::c_int,
        alphar: *mut f64,
        alphai: *mut f64,
        beta: *mut f64,
        csl: *mut f64,
        snl: *mut f64,
        csr: *mut f64,
        snr: *mut f64,
    );
    pub fn dlals0_(
        icompq: *mut ::std::os::raw::c_int,
        nl: *mut ::std::os::raw::c_int,
        nr: *mut ::std::os::raw::c_int,
        sqre: *mut ::std::os::raw::c_int,
        nrhs: *mut ::std::os::raw::c_int,
        b: *mut f64,
        ldb: *mut ::std::os::raw::c_int,
        bx: *mut f64,
        ldbx: *mut ::std::os::raw::c_int,
        perm: *mut ::std::os::raw::c_int,
        givptr: *mut ::std::os::raw::c_int,
        givcol: *mut ::std::os::raw::c_int,
        ldgcol: *mut ::std::os::raw::c_int,
        givnum: *mut f64,
        ldgnum: *mut ::std::os::raw::c_int,
        poles: *mut f64,
        difl: *mut f64,
        difr: *mut f64,
        z: *mut f64,
        k: *mut ::std::os::raw::c_int,
        c: *mut f64,
        s: *mut f64,
        work: *mut f64,
        info: *mut ::std::os::raw::c_int,
    );
    pub fn dlalsa_(
        icompq: *mut ::std::os::raw::c_int,
        smlsiz: *mut ::std::os::raw::c_int,
        n: *mut ::std::os::raw::c_int,
        nrhs: *mut ::std::os::raw::c_int,
        b: *mut f64,
        ldb: *mut ::std::os::raw::c_int,
        bx: *mut f64,
        ldbx: *mut ::std::os::raw::c_int,
        u: *mut f64,
        ldu: *mut ::std::os::raw::c_int,
        vt: *mut f64,
        k: *mut ::std::os::raw::c_int,
        difl: *mut f64,
        difr: *mut f64,
        z: *mut f64,
        poles: *mut f64,
        givptr: *mut ::std::os::raw::c_int,
        givcol: *mut ::std::os::raw::c_int,
        ldgcol: *mut ::std::os::raw::c_int,
        perm: *mut ::std::os::raw::c_int,
        givnum: *mut f64,
        c: *mut f64,
        s: *mut f64,
        work: *mut f64,
        iwork: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    );
    pub fn dlalsd_(
        uplo: *const ::std::os::raw::c_char,
        smlsiz: *mut ::std::os::raw::c_int,
        n: *mut ::std::os::raw::c_int,
        nrhs: *mut ::std::os::raw::c_int,
        d: *mut f64,
        e: *mut f64,
        b: *mut f64,
        ldb: *mut ::std::os::raw::c_int,
        rcond: *mut f64,
        rank: *mut ::std::os::raw::c_int,
        work: *mut f64,
        iwork: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    pub fn dlamc1_(
        beta: *mut ::std::os::raw::c_int,
        t: *mut ::std::os::raw::c_int,
        rnd: *mut ::std::os::raw::c_int,
        ieee1: *mut *mut ::std::os::raw::c_int,
    );
    pub fn dlamc2_(
        beta: *mut ::std::os::raw::c_int,
        t: *mut ::std::os::raw::c_int,
        rnd: *mut ::std::os::raw::c_int,
        eps: *mut f64,
        emin: *mut ::std::os::raw::c_int,
        rmin: *mut f64,
        emax: *mut ::std::os::raw::c_int,
        rmax: *mut f64,
    );
    pub fn dlamc3_(a: *mut f64, b: *mut f64) -> f64;
    pub fn dlamc4_(
        emin: *mut ::std::os::raw::c_int,
        start: *mut f64,
        base: *mut ::std::os::raw::c_int,
    );
    pub fn dlamc5_(
        beta: *mut ::std::os::raw::c_int,
        p: *mut ::std::os::raw::c_int,
        emin: *mut ::std::os::raw::c_int,
        ieee: *mut ::std::os::raw::c_int,
        emax: *mut ::std::os::raw::c_int,
        rmax: *mut f64,
    );
    pub fn dlaqp2_(
        m: *mut ::std::os::raw::c_int,
        n: *mut ::std::os::raw::c_int,
        offset: *mut ::std::os::raw::c_int,
        a: *mut f64,
        lda: *mut ::std::os::raw::c_int,
        jpvt: *mut ::std::os::raw::c_int,
        tau: *mut f64,
        vn1: *mut f64,
        vn2: *mut f64,
        work: *mut f64,
    );
    pub fn dlaqps_(
        m: *mut ::std::os::raw::c_int,
        n: *mut ::std::os::raw::c_int,
        offset: *mut ::std::os::raw::c_int,
        nb: *mut ::std::os::raw::c_int,
        kb: *mut ::std::os::raw::c_int,
        a: *mut f64,
        lda: *mut ::std::os::raw::c_int,
        jpvt: *mut ::std::os::raw::c_int,
        tau: *mut f64,
        vn1: *mut f64,
        vn2: *mut f64,
        auxv: *mut f64,
        f: *mut f64,
        ldf: *mut ::std::os::raw::c_int,
    );
    pub fn dlar1v_(
        n: *mut ::std::os::raw::c_int,
        b1: *mut ::std::os::raw::c_int,
        bn: *mut ::std::os::raw::c_int,
        sigma: *mut f64,
        d: *mut f64,
        l: *mut f64,
        ld: *mut f64,
        lld: *mut f64,
        gersch: *mut f64,
        z: *mut f64,
        ztz: *mut f64,
        mingma: *mut f64,
        r: *mut ::std::os::raw::c_int,
        isuppz: *mut ::std::os::raw::c_int,
        work: *mut f64,
    );
    pub fn dlarrb_(
        n: *mut ::std::os::raw::c_int,
        d: *mut f64,
        l: *mut f64,
        ld: *mut f64,
        lld: *mut f64,
        ifirst: *mut ::std::os::raw::c_int,
        ilast: *mut ::std::os::raw::c_int,
        sigma: *mut f64,
        reltol: *mut f64,
        w: *mut f64,
        wgap: *mut f64,
        werr: *mut f64,
        work: *mut f64,
        iwork: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    );
    pub fn dlarre_(
        n: *mut ::std::os::raw::c_int,
        d: *mut f64,
        e: *mut f64,
        tol: *mut f64,
        nsplit: *mut ::std::os::raw::c_int,
        isplit: *mut ::std::os::raw::c_int,
        m: *mut ::std::os::raw::c_int,
        w: *mut f64,
        woff: *mut f64,
        gersch: *mut f64,
        work: *mut f64,
        info: *mut ::std::os::raw::c_int,
    );
    pub fn dlarrf_(
        n: *mut ::std::os::raw::c_int,
        d: *mut f64,
        l: *mut f64,
        ld: *mut f64,
        lld: *mut f64,
        ifirst: *mut ::std::os::raw::c_int,
        ilast: *mut ::std::os::raw::c_int,
        w: *mut f64,
        dplus: *mut f64,
        lplus: *mut f64,
        work: *mut f64,
        iwork: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    );
    pub fn dlarrv_(
        n: *mut ::std::os::raw::c_int,
        d: *mut f64,
        l: *mut f64,
        isplit: *mut ::std::os::raw::c_int,
        m: *mut ::std::os::raw::c_int,
        w: *mut f64,
        iblock: *mut ::std::os::raw::c_int,
        gersch: *mut f64,
        tol: *mut f64,
        z: *mut f64,
        ldz: *mut ::std::os::raw::c_int,
        isuppz: *mut ::std::os::raw::c_int,
        work: *mut f64,
        iwork: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    );
    pub fn dlarz_(
        side: *const ::std::os::raw::c_char,
        m: *mut ::std::os::raw::c_int,
        n: *mut ::std::os::raw::c_int,
        l: *mut ::std::os::raw::c_int,
        v: *mut f64,
        incv: *mut ::std::os::raw::c_int,
        tau: *mut f64,
        c: *mut f64,
        ldc: *mut ::std::os::raw::c_int,
        work: *mut f64,
        arg1: usize,
    );
    pub fn dlarzb_(
        side: *const ::std::os::raw::c_char,
        trans: *const ::std::os::raw::c_char,
        direct: *const ::std::os::raw::c_char,
        storev: *const ::std::os::raw::c_char,
        m: *mut ::std::os::raw::c_int,
        n: *mut ::std::os::raw::c_int,
        k: *mut ::std::os::raw::c_int,
        l: *mut ::std::os::raw::c_int,
        v: *mut f64,
        ldv: *mut ::std::os::raw::c_int,
        t: *mut f64,
        ldt: *mut ::std::os::raw::c_int,
        c: *mut f64,
        ldc: *mut ::std::os::raw::c_int,
        work: *mut f64,
        ldwork: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
        arg3: usize,
        arg4: usize,
    );
    pub fn dlarzt_(
        direct: *const ::std::os::raw::c_char,
        storev: *const ::std::os::raw::c_char,
        n: *mut ::std::os::raw::c_int,
        k: *mut ::std::os::raw::c_int,
        v: *mut f64,
        ldv: *mut ::std::os::raw::c_int,
        tau: *mut f64,
        t: *mut f64,
        ldt: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
    );
    pub fn dlasd0_(
        n: *mut ::std::os::raw::c_int,
        sqre: *mut ::std::os::raw::c_int,
        d: *mut f64,
        e: *mut f64,
        u: *mut f64,
        ldu: *mut ::std::os::raw::c_int,
        vt: *mut f64,
        ldvt: *mut ::std::os::raw::c_int,
        smlsiz: *mut ::std::os::raw::c_int,
        iwork: *mut ::std::os::raw::c_int,
        work: *mut f64,
        info: *mut ::std::os::raw::c_int,
    );
    pub fn dlasd1_(
        nl: *mut ::std::os::raw::c_int,
        nr: *mut ::std::os::raw::c_int,
        sqre: *mut ::std::os::raw::c_int,
        d: *mut f64,
        alpha: *mut f64,
        beta: *mut f64,
        u: *mut f64,
        ldu: *mut ::std::os::raw::c_int,
        vt: *mut f64,
        ldvt: *mut ::std::os::raw::c_int,
        idxq: *mut ::std::os::raw::c_int,
        iwork: *mut ::std::os::raw::c_int,
        work: *mut f64,
        info: *mut ::std::os::raw::c_int,
    );
    pub fn dlasd2_(
        nl: *mut ::std::os::raw::c_int,
        nr: *mut ::std::os::raw::c_int,
        sqre: *mut ::std::os::raw::c_int,
        k: *mut *mut ::std::os::raw::c_int,
        d: *mut f64,
        z: *mut f64,
        alpha: *mut f64,
        beta: *mut f64,
        u: *mut f64,
        ldu: *mut ::std::os::raw::c_int,
        vt: *mut f64,
        ldvt: *mut ::std::os::raw::c_int,
        dsigma: *mut f64,
        u2: *mut f64,
        ldu2: *mut ::std::os::raw::c_int,
        vt2: *mut f64,
        ldvt2: *mut ::std::os::raw::c_int,
        idxp: *mut ::std::os::raw::c_int,
        idx: *mut ::std::os::raw::c_int,
        idxc: *mut ::std::os::raw::c_int,
        idxq: *mut ::std::os::raw::c_int,
        coltyp: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    );
    pub fn dlasd3_(
        nl: *mut ::std::os::raw::c_int,
        nr: *mut ::std::os::raw::c_int,
        sqre: *mut ::std::os::raw::c_int,
        k: *mut *mut ::std::os::raw::c_int,
        d: *mut f64,
        q: *mut f64,
        ldq: *mut ::std::os::raw::c_int,
        dsigma: *mut f64,
        u: *mut f64,
        ldu: *mut ::std::os::raw::c_int,
        u2: *mut f64,
        ldu2: *mut ::std::os::raw::c_int,
        vt: *mut f64,
        ldvt: *mut ::std::os::raw::c_int,
        vt2: *mut f64,
        ldvt2: *mut ::std::os::raw::c_int,
        idxc: *mut ::std::os::raw::c_int,
        ctot: *mut ::std::os::raw::c_int,
        z: *mut f64,
        info: *mut ::std::os::raw::c_int,
    );
    pub fn dlasd4_(
        n: *mut ::std::os::raw::c_int,
        i: *mut ::std::os::raw::c_int,
        d: *mut f64,
        z: *mut f64,
        delta: *mut f64,
        rho: *mut f64,
        sigma: *mut f64,
        work: *mut f64,
        info: *mut ::std::os::raw::c_int,
    );
    pub fn dlasd5_(
        i: *mut ::std::os::raw::c_int,
        d: *mut f64,
        z: *mut f64,
        delta: *mut f64,
        rho: *mut f64,
        dsigma: *mut f64,
        work: *mut f64,
    );
    pub fn dlasd6_(
        icompq: *mut ::std::os::raw::c_int,
        nl: *mut ::std::os::raw::c_int,
        nr: *mut ::std::os::raw::c_int,
        sqre: *mut ::std::os::raw::c_int,
        d: *mut f64,
        vf: *mut f64,
        vl: *mut f64,
        alpha: *mut f64,
        beta: *mut f64,
        idxq: *mut ::std::os::raw::c_int,
        perm: *mut ::std::os::raw::c_int,
        givptr: *mut ::std::os::raw::c_int,
        givcol: *mut ::std::os::raw::c_int,
        ldgcol: *mut ::std::os::raw::c_int,
        givnum: *mut f64,
        ldgnum: *mut ::std::os::raw::c_int,
        poles: *mut f64,
        difl: *mut f64,
        difr: *mut f64,
        z: *mut f64,
        k: *mut ::std::os::raw::c_int,
        c: *mut f64,
        s: *mut f64,
        work: *mut f64,
        iwork: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    );
    pub fn dlasd7_(
        icompq: *mut ::std::os::raw::c_int,
        nl: *mut ::std::os::raw::c_int,
        nr: *mut ::std::os::raw::c_int,
        sqre: *mut ::std::os::raw::c_int,
        k: *mut ::std::os::raw::c_int,
        d: *mut f64,
        z: *mut f64,
        zw: *mut f64,
        vf: *mut f64,
        vfw: *mut f64,
        vl: *mut f64,
        vlw: *mut f64,
        alpha: *mut f64,
        beta: *mut f64,
        dsigma: *mut f64,
        idx: *mut ::std::os::raw::c_int,
        idxp: *mut ::std::os::raw::c_int,
        idxq: *mut ::std::os::raw::c_int,
        perm: *mut ::std::os::raw::c_int,
        givptr: *mut ::std::os::raw::c_int,
        givcol: *mut ::std::os::raw::c_int,
        ldgcol: *mut ::std::os::raw::c_int,
        givnum: *mut f64,
        ldgnum: *mut ::std::os::raw::c_int,
        c: *mut f64,
        s: *mut f64,
        info: *mut ::std::os::raw::c_int,
    );
    pub fn dlasd8_(
        icompq: *mut ::std::os::raw::c_int,
        k: *mut ::std::os::raw::c_int,
        d: *mut f64,
        z: *mut f64,
        vf: *mut f64,
        vl: *mut f64,
        difl: *mut f64,
        difr: *mut f64,
        lddifr: *mut ::std::os::raw::c_int,
        dsigma: *mut f64,
        work: *mut f64,
        info: *mut ::std::os::raw::c_int,
    );
    pub fn dlasd9_(
        icompq: *mut ::std::os::raw::c_int,
        ldu: *mut ::std::os::raw::c_int,
        k: *mut ::std::os::raw::c_int,
        d: *mut f64,
        z: *mut f64,
        vf: *mut f64,
        vl: *mut f64,
        difl: *mut f64,
        difr: *mut f64,
        dsigma: *mut f64,
        work: *mut f64,
        info: *mut ::std::os::raw::c_int,
    );
    pub fn dlasda_(
        icompq: *mut ::std::os::raw::c_int,
        smlsiz: *mut ::std::os::raw::c_int,
        n: *mut ::std::os::raw::c_int,
        sqre: *mut ::std::os::raw::c_int,
        d: *mut f64,
        e: *mut f64,
        u: *mut f64,
        ldu: *mut *mut ::std::os::raw::c_int,
        vt: *mut f64,
        k: *mut ::std::os::raw::c_int,
        difl: *mut f64,
        difr: *mut f64,
        z: *mut f64,
        poles: *mut f64,
        givptr: *mut ::std::os::raw::c_int,
        givcol: *mut ::std::os::raw::c_int,
        ldgcol: *mut ::std::os::raw::c_int,
        perm: *mut ::std::os::raw::c_int,
        givnum: *mut f64,
        c: *mut f64,
        s: *mut f64,
        work: *mut f64,
        iwork: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    );
    pub fn dlasdq_(
        uplo: *const ::std::os::raw::c_char,
        sqre: *mut ::std::os::raw::c_int,
        n: *mut ::std::os::raw::c_int,
        ncvt: *mut ::std::os::raw::c_int,
        nru: *mut ::std::os::raw::c_int,
        ncc: *mut ::std::os::raw::c_int,
        d: *mut f64,
        e: *mut f64,
        vt: *mut f64,
        ldvt: *mut ::std::os::raw::c_int,
        u: *mut f64,
        ldu: *mut ::std::os::raw::c_int,
        c: *mut f64,
        ldc: *mut ::std::os::raw::c_int,
        work: *mut f64,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    pub fn dlasdt_(
        n: *mut ::std::os::raw::c_int,
        lvl: *mut ::std::os::raw::c_int,
        nd: *mut ::std::os::raw::c_int,
        inode: *mut ::std::os::raw::c_int,
        ndiml: *mut ::std::os::raw::c_int,
        ndimr: *mut ::std::os::raw::c_int,
        msub: *mut ::std::os::raw::c_int,
    );
    pub fn dlasq5_(
        i0: *mut ::std::os::raw::c_int,
        n0: *mut ::std::os::raw::c_int,
        z: *mut f64,
        pp: *mut ::std::os::raw::c_int,
        tau: *mut f64,
        dmin: *mut f64,
        dmin1: *mut f64,
        dmin2: *mut f64,
        dn: *mut f64,
        dnm1: *mut f64,
        dnm2: *mut f64,
        ieee: *mut ::std::os::raw::c_int,
    );
    pub fn dlasq6_(
        i0: *mut ::std::os::raw::c_int,
        n0: *mut ::std::os::raw::c_int,
        z: *mut f64,
        pp: *mut ::std::os::raw::c_int,
        dmin: *mut f64,
        dmin1: *mut f64,
        dmin2: *mut f64,
        dn: *mut f64,
        dnm1: *mut f64,
        dnm2: *mut f64,
    );
    pub fn dlatdf_(
        ijob: *mut ::std::os::raw::c_int,
        n: *mut ::std::os::raw::c_int,
        z: *mut f64,
        ldz: *mut ::std::os::raw::c_int,
        rhs: *mut f64,
        rdsum: *mut f64,
        rdscal: *mut f64,
        ipiv: *mut ::std::os::raw::c_int,
        jpiv: *mut ::std::os::raw::c_int,
    );
    pub fn dlatrz_(
        m: *mut ::std::os::raw::c_int,
        n: *mut ::std::os::raw::c_int,
        l: *mut ::std::os::raw::c_int,
        a: *mut f64,
        lda: *mut ::std::os::raw::c_int,
        tau: *mut f64,
        work: *mut f64,
    );
    pub fn dormr3_(
        side: *const ::std::os::raw::c_char,
        trans: *const ::std::os::raw::c_char,
        m: *mut ::std::os::raw::c_int,
        n: *mut ::std::os::raw::c_int,
        k: *mut ::std::os::raw::c_int,
        l: *mut ::std::os::raw::c_int,
        a: *mut f64,
        lda: *mut ::std::os::raw::c_int,
        tau: *mut f64,
        c: *mut f64,
        ldc: *mut ::std::os::raw::c_int,
        work: *mut f64,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
    );
    pub fn dormrz_(
        side: *const ::std::os::raw::c_char,
        trans: *const ::std::os::raw::c_char,
        m: *mut ::std::os::raw::c_int,
        n: *mut ::std::os::raw::c_int,
        k: *mut ::std::os::raw::c_int,
        l: *mut ::std::os::raw::c_int,
        a: *mut f64,
        lda: *mut ::std::os::raw::c_int,
        tau: *mut f64,
        c: *mut f64,
        ldc: *mut ::std::os::raw::c_int,
        work: *mut f64,
        lwork: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
    );
    pub fn dptts2_(
        n: *mut ::std::os::raw::c_int,
        nrhs: *mut ::std::os::raw::c_int,
        d: *mut f64,
        e: *mut f64,
        b: *mut f64,
        ldb: *mut ::std::os::raw::c_int,
    );
    pub fn dsbgvd_(
        jobz: *const ::std::os::raw::c_char,
        uplo: *const ::std::os::raw::c_char,
        n: *mut ::std::os::raw::c_int,
        ka: *mut ::std::os::raw::c_int,
        kb: *mut ::std::os::raw::c_int,
        ab: *mut f64,
        ldab: *mut ::std::os::raw::c_int,
        bb: *mut f64,
        ldbb: *mut ::std::os::raw::c_int,
        w: *mut f64,
        z: *mut f64,
        ldz: *mut ::std::os::raw::c_int,
        work: *mut f64,
        lwork: *mut ::std::os::raw::c_int,
        iwork: *mut ::std::os::raw::c_int,
        liwork: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
    );
    pub fn dsbgvx_(
        jobz: *const ::std::os::raw::c_char,
        range: *const ::std::os::raw::c_char,
        uplo: *const ::std::os::raw::c_char,
        n: *mut ::std::os::raw::c_int,
        ka: *mut ::std::os::raw::c_int,
        kb: *mut ::std::os::raw::c_int,
        ab: *mut f64,
        ldab: *mut ::std::os::raw::c_int,
        bb: *mut f64,
        ldbb: *mut ::std::os::raw::c_int,
        q: *mut f64,
        ldq: *mut ::std::os::raw::c_int,
        vl: *mut f64,
        vu: *mut f64,
        il: *mut ::std::os::raw::c_int,
        iu: *mut ::std::os::raw::c_int,
        abstol: *mut f64,
        m: *mut *mut ::std::os::raw::c_int,
        w: *mut f64,
        z: *mut f64,
        ldz: *mut ::std::os::raw::c_int,
        work: *mut f64,
        iwork: *mut ::std::os::raw::c_int,
        ifail: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
        arg3: usize,
    );
    pub fn dspgvd_(
        itype: *mut ::std::os::raw::c_int,
        jobz: *const ::std::os::raw::c_char,
        uplo: *const ::std::os::raw::c_char,
        n: *mut ::std::os::raw::c_int,
        ap: *mut f64,
        bp: *mut f64,
        w: *mut f64,
        z: *mut f64,
        ldz: *mut ::std::os::raw::c_int,
        work: *mut f64,
        lwork: *mut ::std::os::raw::c_int,
        iwork: *mut ::std::os::raw::c_int,
        liwork: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
    );
    pub fn dspgvx_(
        itype: *mut ::std::os::raw::c_int,
        jobz: *const ::std::os::raw::c_char,
        range: *const ::std::os::raw::c_char,
        uplo: *const ::std::os::raw::c_char,
        n: *mut ::std::os::raw::c_int,
        ap: *mut f64,
        bp: *mut f64,
        vl: *mut f64,
        vu: *mut f64,
        il: *mut ::std::os::raw::c_int,
        iu: *mut ::std::os::raw::c_int,
        abstol: *mut f64,
        m: *mut *mut ::std::os::raw::c_int,
        w: *mut f64,
        z: *mut f64,
        ldz: *mut ::std::os::raw::c_int,
        work: *mut f64,
        iwork: *mut ::std::os::raw::c_int,
        ifail: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
        arg3: usize,
    );
    pub fn dstegr_(
        jobz: *const ::std::os::raw::c_char,
        range: *const ::std::os::raw::c_char,
        n: *mut ::std::os::raw::c_int,
        d: *mut f64,
        e: *mut f64,
        vl: *mut f64,
        vu: *mut f64,
        il: *mut ::std::os::raw::c_int,
        iu: *mut ::std::os::raw::c_int,
        abstol: *mut f64,
        m: *mut ::std::os::raw::c_int,
        w: *mut f64,
        z: *mut f64,
        ldz: *mut ::std::os::raw::c_int,
        isuppz: *mut ::std::os::raw::c_int,
        work: *mut f64,
        lwork: *mut ::std::os::raw::c_int,
        iwork: *mut ::std::os::raw::c_int,
        liwork: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
    );
    pub fn dstevr_(
        jobz: *const ::std::os::raw::c_char,
        range: *const ::std::os::raw::c_char,
        n: *mut ::std::os::raw::c_int,
        d: *mut f64,
        e: *mut f64,
        vl: *mut f64,
        vu: *mut f64,
        il: *mut ::std::os::raw::c_int,
        iu: *mut ::std::os::raw::c_int,
        abstol: *mut f64,
        m: *mut ::std::os::raw::c_int,
        w: *mut f64,
        z: *mut f64,
        ldz: *mut ::std::os::raw::c_int,
        isuppz: *mut ::std::os::raw::c_int,
        work: *mut f64,
        lwork: *mut ::std::os::raw::c_int,
        iwork: *mut ::std::os::raw::c_int,
        liwork: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
    );
    pub fn dsygvd_(
        itype: *mut ::std::os::raw::c_int,
        jobz: *const ::std::os::raw::c_char,
        uplo: *const ::std::os::raw::c_char,
        n: *mut ::std::os::raw::c_int,
        a: *mut f64,
        lda: *mut ::std::os::raw::c_int,
        b: *mut f64,
        ldb: *mut ::std::os::raw::c_int,
        w: *mut f64,
        work: *mut f64,
        lwork: *mut ::std::os::raw::c_int,
        iwork: *mut ::std::os::raw::c_int,
        liwork: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
    );
    pub fn dsygvx_(
        itype: *mut ::std::os::raw::c_int,
        jobz: *const ::std::os::raw::c_char,
        range: *const ::std::os::raw::c_char,
        uplo: *const ::std::os::raw::c_char,
        n: *mut ::std::os::raw::c_int,
        a: *mut f64,
        lda: *mut ::std::os::raw::c_int,
        b: *mut f64,
        ldb: *mut ::std::os::raw::c_int,
        vl: *mut f64,
        vu: *mut f64,
        il: *mut ::std::os::raw::c_int,
        iu: *mut ::std::os::raw::c_int,
        abstol: *mut f64,
        m: *mut ::std::os::raw::c_int,
        w: *mut f64,
        z: *mut f64,
        ldz: *mut ::std::os::raw::c_int,
        work: *mut f64,
        lwork: *mut ::std::os::raw::c_int,
        iwork: *mut ::std::os::raw::c_int,
        ifail: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
        arg3: usize,
    );
    pub fn dtgex2_(
        wantq: *const ::std::os::raw::c_int,
        wantz: *const ::std::os::raw::c_int,
        n: *mut ::std::os::raw::c_int,
        a: *mut f64,
        lda: *mut ::std::os::raw::c_int,
        b: *mut f64,
        ldb: *mut ::std::os::raw::c_int,
        q: *mut f64,
        ldq: *mut ::std::os::raw::c_int,
        z: *mut f64,
        ldz: *mut ::std::os::raw::c_int,
        j1: *mut ::std::os::raw::c_int,
        n1: *mut ::std::os::raw::c_int,
        n2: *mut ::std::os::raw::c_int,
        work: *mut f64,
        lwork: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    );
    pub fn dtgexc_(
        wantq: *mut ::std::os::raw::c_int,
        wantz: *mut ::std::os::raw::c_int,
        n: *mut ::std::os::raw::c_int,
        a: *mut f64,
        lda: *mut ::std::os::raw::c_int,
        b: *mut f64,
        ldb: *mut ::std::os::raw::c_int,
        q: *mut f64,
        ldq: *mut ::std::os::raw::c_int,
        z: *mut f64,
        ldz: *mut ::std::os::raw::c_int,
        ifst: *mut ::std::os::raw::c_int,
        ilst: *mut ::std::os::raw::c_int,
        work: *mut f64,
        lwork: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    );
    pub fn dtgsen_(
        ijob: *mut ::std::os::raw::c_int,
        wantq: *const ::std::os::raw::c_int,
        wantz: *const ::std::os::raw::c_int,
        select: *const ::std::os::raw::c_int,
        n: *mut ::std::os::raw::c_int,
        a: *mut f64,
        lda: *mut ::std::os::raw::c_int,
        b: *mut f64,
        ldb: *mut ::std::os::raw::c_int,
        alphar: *mut f64,
        alphai: *mut f64,
        beta: *mut f64,
        q: *mut f64,
        ldq: *mut ::std::os::raw::c_int,
        z: *mut f64,
        ldz: *mut ::std::os::raw::c_int,
        m: *mut ::std::os::raw::c_int,
        pl: *mut f64,
        pr: *mut f64,
        dif: *mut f64,
        work: *mut f64,
        lwork: *mut ::std::os::raw::c_int,
        iwork: *mut ::std::os::raw::c_int,
        liwork: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    );
    pub fn dtgsna_(
        job: *const ::std::os::raw::c_char,
        howmny: *const ::std::os::raw::c_char,
        select: *mut ::std::os::raw::c_int,
        n: *mut ::std::os::raw::c_int,
        a: *mut f64,
        lda: *mut ::std::os::raw::c_int,
        b: *mut f64,
        ldb: *mut ::std::os::raw::c_int,
        vl: *mut f64,
        ldvl: *mut ::std::os::raw::c_int,
        vr: *mut f64,
        ldvr: *mut ::std::os::raw::c_int,
        s: *mut f64,
        dif: *mut f64,
        mm: *mut ::std::os::raw::c_int,
        m: *mut ::std::os::raw::c_int,
        work: *mut f64,
        lwork: *mut ::std::os::raw::c_int,
        iwork: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
    );
    pub fn dtgsy2_(
        trans: *const ::std::os::raw::c_char,
        ijob: *mut ::std::os::raw::c_int,
        m: *mut ::std::os::raw::c_int,
        n: *mut ::std::os::raw::c_int,
        a: *mut f64,
        lda: *mut ::std::os::raw::c_int,
        b: *mut f64,
        ldb: *mut ::std::os::raw::c_int,
        c: *mut f64,
        ldc: *mut ::std::os::raw::c_int,
        d: *mut f64,
        ldd: *mut ::std::os::raw::c_int,
        e: *mut f64,
        lde: *mut ::std::os::raw::c_int,
        f: *mut f64,
        ldf: *mut ::std::os::raw::c_int,
        scale: *mut f64,
        rdsum: *mut f64,
        rdscal: *mut f64,
        iwork: *mut ::std::os::raw::c_int,
        pq: *mut *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    pub fn dtgsyl_(
        trans: *const ::std::os::raw::c_char,
        ijob: *mut ::std::os::raw::c_int,
        m: *mut ::std::os::raw::c_int,
        n: *mut ::std::os::raw::c_int,
        a: *mut f64,
        lda: *mut ::std::os::raw::c_int,
        b: *mut f64,
        ldb: *mut ::std::os::raw::c_int,
        c: *mut f64,
        ldc: *mut ::std::os::raw::c_int,
        d: *mut f64,
        ldd: *mut ::std::os::raw::c_int,
        e: *mut f64,
        lde: *mut ::std::os::raw::c_int,
        f: *mut f64,
        ldf: *mut ::std::os::raw::c_int,
        scale: *mut f64,
        dif: *mut f64,
        work: *mut f64,
        lwork: *mut ::std::os::raw::c_int,
        iwork: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    pub fn dtzrzf_(
        m: *mut ::std::os::raw::c_int,
        n: *mut ::std::os::raw::c_int,
        a: *mut f64,
        lda: *mut ::std::os::raw::c_int,
        tau: *mut f64,
        work: *mut f64,
        lwork: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    );
    pub fn dpstrf_(
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        a: *mut f64,
        lda: *const ::std::os::raw::c_int,
        piv: *mut ::std::os::raw::c_int,
        rank: *mut ::std::os::raw::c_int,
        tol: *mut f64,
        work: *mut f64,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    #[doc = "This returns Fortran LOGICAL.  See comments at the top of the file.\nclapack and Accelerate headers declare lsamen but not lsame.\n\nSome people regard this as part of BLAS, and it is used on some\nBLAS routines.  However, it is not included by\nApple's Accelerate (nor cblas: it is in lapacke)."]
    pub fn lsame_(
        ca: *const ::std::os::raw::c_char,
        cb: *const ::std::os::raw::c_char,
        arg1: usize,
        arg2: usize,
    ) -> *mut ::std::os::raw::c_int;
    pub fn zbdsqr_(
        uplo: *const ::std::os::raw::c_char,
        n: *mut ::std::os::raw::c_int,
        ncvt: *mut ::std::os::raw::c_int,
        nru: *mut ::std::os::raw::c_int,
        ncc: *mut ::std::os::raw::c_int,
        d: *mut f64,
        e: *mut f64,
        vt: *mut Rcomplex,
        ldvt: *mut ::std::os::raw::c_int,
        u: *mut Rcomplex,
        ldu: *mut ::std::os::raw::c_int,
        c: *mut Rcomplex,
        ldc: *mut ::std::os::raw::c_int,
        rwork: *mut f64,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    pub fn zdrot_(
        n: *const ::std::os::raw::c_int,
        cx: *const Rcomplex,
        incx: *const ::std::os::raw::c_int,
        cy: *mut Rcomplex,
        incy: *const ::std::os::raw::c_int,
        c: *const f64,
        s: *const f64,
    );
    pub fn zgebak_(
        job: *const ::std::os::raw::c_char,
        side: *const ::std::os::raw::c_char,
        n: *mut ::std::os::raw::c_int,
        ilo: *mut ::std::os::raw::c_int,
        ihi: *mut ::std::os::raw::c_int,
        scale: *mut f64,
        m: *mut ::std::os::raw::c_int,
        v: *mut Rcomplex,
        ldv: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
    );
    pub fn zgebal_(
        job: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        a: *mut Rcomplex,
        lda: *const ::std::os::raw::c_int,
        ilo: *mut ::std::os::raw::c_int,
        ihi: *mut ::std::os::raw::c_int,
        scale: *mut f64,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    pub fn zgebd2_(
        m: *mut ::std::os::raw::c_int,
        n: *mut ::std::os::raw::c_int,
        a: *mut Rcomplex,
        lda: *mut ::std::os::raw::c_int,
        d: *mut f64,
        e: *mut f64,
        tauq: *mut Rcomplex,
        taup: *mut Rcomplex,
        work: *mut Rcomplex,
        info: *mut ::std::os::raw::c_int,
    );
    pub fn zgebrd_(
        m: *mut ::std::os::raw::c_int,
        n: *mut ::std::os::raw::c_int,
        a: *mut Rcomplex,
        lda: *mut ::std::os::raw::c_int,
        d: *mut f64,
        e: *mut f64,
        tauq: *mut Rcomplex,
        taup: *mut Rcomplex,
        work: *mut Rcomplex,
        lwork: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    );
    pub fn zgehd2_(
        n: *mut ::std::os::raw::c_int,
        ilo: *mut ::std::os::raw::c_int,
        ihi: *mut ::std::os::raw::c_int,
        a: *mut Rcomplex,
        lda: *mut ::std::os::raw::c_int,
        tau: *mut Rcomplex,
        work: *mut Rcomplex,
        info: *mut ::std::os::raw::c_int,
    );
    pub fn zgehrd_(
        n: *mut ::std::os::raw::c_int,
        ilo: *mut ::std::os::raw::c_int,
        ihi: *mut ::std::os::raw::c_int,
        a: *mut Rcomplex,
        lda: *mut ::std::os::raw::c_int,
        tau: *mut Rcomplex,
        work: *mut Rcomplex,
        lwork: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    );
    pub fn zgelq2_(
        m: *mut ::std::os::raw::c_int,
        n: *mut ::std::os::raw::c_int,
        a: *mut Rcomplex,
        lda: *mut ::std::os::raw::c_int,
        tau: *mut Rcomplex,
        work: *mut Rcomplex,
        info: *mut ::std::os::raw::c_int,
    );
    pub fn zgelqf_(
        m: *mut ::std::os::raw::c_int,
        n: *mut ::std::os::raw::c_int,
        a: *mut Rcomplex,
        lda: *mut ::std::os::raw::c_int,
        tau: *mut Rcomplex,
        work: *mut Rcomplex,
        lwork: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    );
    pub fn zgeqr2_(
        m: *mut ::std::os::raw::c_int,
        n: *mut ::std::os::raw::c_int,
        a: *mut Rcomplex,
        lda: *mut ::std::os::raw::c_int,
        tau: *mut Rcomplex,
        work: *mut Rcomplex,
        info: *mut ::std::os::raw::c_int,
    );
    pub fn zgeqrf_(
        m: *mut ::std::os::raw::c_int,
        n: *mut ::std::os::raw::c_int,
        a: *mut Rcomplex,
        lda: *mut ::std::os::raw::c_int,
        tau: *mut Rcomplex,
        work: *mut Rcomplex,
        lwork: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    );
    pub fn zgetf2_(
        m: *mut ::std::os::raw::c_int,
        n: *mut ::std::os::raw::c_int,
        a: *mut Rcomplex,
        lda: *mut ::std::os::raw::c_int,
        ipiv: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    );
    pub fn zgetrf_(
        m: *mut ::std::os::raw::c_int,
        n: *mut ::std::os::raw::c_int,
        a: *mut Rcomplex,
        lda: *mut ::std::os::raw::c_int,
        ipiv: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    );
    pub fn zgetrf2_(
        m: *mut ::std::os::raw::c_int,
        n: *mut ::std::os::raw::c_int,
        a: *mut Rcomplex,
        lda: *mut ::std::os::raw::c_int,
        ipiv: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    );
    #[doc = "ZGETRI computes the inverse of a matrix using the LU factorization\n computed by ZGETRF.\n Added in R 3.3.0"]
    pub fn zgetri_(
        n: *mut ::std::os::raw::c_int,
        a: *mut Rcomplex,
        lda: *mut ::std::os::raw::c_int,
        ipiv: *mut ::std::os::raw::c_int,
        work: *mut Rcomplex,
        lwork: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    );
    pub fn zgetrs_(
        trans: *const ::std::os::raw::c_char,
        n: *mut ::std::os::raw::c_int,
        nrhs: *mut ::std::os::raw::c_int,
        a: *mut Rcomplex,
        lda: *mut ::std::os::raw::c_int,
        ipiv: *mut ::std::os::raw::c_int,
        b: *mut Rcomplex,
        ldb: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    pub fn zhetd2_(
        uplo: *const ::std::os::raw::c_char,
        n: *mut ::std::os::raw::c_int,
        a: *mut Rcomplex,
        lda: *mut ::std::os::raw::c_int,
        d: *mut f64,
        e: *mut f64,
        tau: *mut Rcomplex,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    pub fn zhetrd_(
        uplo: *const ::std::os::raw::c_char,
        n: *mut ::std::os::raw::c_int,
        a: *mut Rcomplex,
        lda: *mut ::std::os::raw::c_int,
        d: *mut f64,
        e: *mut f64,
        tau: *mut Rcomplex,
        work: *mut Rcomplex,
        lwork: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    pub fn zhseqr_(
        job: *const ::std::os::raw::c_char,
        compz: *const ::std::os::raw::c_char,
        n: *mut ::std::os::raw::c_int,
        ilo: *mut ::std::os::raw::c_int,
        ihi: *mut ::std::os::raw::c_int,
        h: *mut Rcomplex,
        ldh: *mut ::std::os::raw::c_int,
        w: *mut Rcomplex,
        z: *mut Rcomplex,
        ldz: *mut ::std::os::raw::c_int,
        work: *mut Rcomplex,
        lwork: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
    );
    pub fn zlabrd_(
        m: *mut ::std::os::raw::c_int,
        n: *mut ::std::os::raw::c_int,
        nb: *mut ::std::os::raw::c_int,
        a: *mut Rcomplex,
        lda: *mut ::std::os::raw::c_int,
        d: *mut f64,
        e: *mut f64,
        tauq: *mut Rcomplex,
        taup: *mut Rcomplex,
        x: *mut Rcomplex,
        ldx: *mut ::std::os::raw::c_int,
        y: *mut Rcomplex,
        ldy: *mut ::std::os::raw::c_int,
    );
    pub fn zlacgv_(
        n: *mut ::std::os::raw::c_int,
        x: *mut Rcomplex,
        incx: *mut ::std::os::raw::c_int,
    );
    pub fn zlacpy_(
        uplo: *const ::std::os::raw::c_char,
        m: *mut ::std::os::raw::c_int,
        n: *mut ::std::os::raw::c_int,
        a: *mut Rcomplex,
        lda: *mut ::std::os::raw::c_int,
        b: *mut Rcomplex,
        ldb: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    pub fn zlahqr_(
        wantt: *mut ::std::os::raw::c_int,
        wantz: *mut ::std::os::raw::c_int,
        n: *mut ::std::os::raw::c_int,
        ilo: *mut ::std::os::raw::c_int,
        ihi: *mut ::std::os::raw::c_int,
        h: *mut Rcomplex,
        ldh: *mut ::std::os::raw::c_int,
        w: *mut Rcomplex,
        iloz: *mut ::std::os::raw::c_int,
        ihiz: *mut ::std::os::raw::c_int,
        z: *mut Rcomplex,
        ldz: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    );
    pub fn zlange_(
        norm: *const ::std::os::raw::c_char,
        m: *mut ::std::os::raw::c_int,
        n: *mut ::std::os::raw::c_int,
        a: *mut Rcomplex,
        lda: *mut ::std::os::raw::c_int,
        work: *mut f64,
        arg1: usize,
    ) -> f64;
    pub fn zlanhe_(
        norm: *const ::std::os::raw::c_char,
        uplo: *const ::std::os::raw::c_char,
        n: *mut ::std::os::raw::c_int,
        a: *mut Rcomplex,
        lda: *mut ::std::os::raw::c_int,
        work: *mut f64,
        arg1: usize,
        arg2: usize,
    ) -> f64;
    pub fn zlanhs_(
        norm: *const ::std::os::raw::c_char,
        n: *mut ::std::os::raw::c_int,
        a: *mut Rcomplex,
        lda: *mut ::std::os::raw::c_int,
        work: *mut f64,
        arg1: usize,
    ) -> f64;
    pub fn zlantp_(
        norm: *const ::std::os::raw::c_char,
        uplo: *const ::std::os::raw::c_char,
        diag: *const ::std::os::raw::c_char,
        n: *mut ::std::os::raw::c_int,
        ap: *mut Rcomplex,
        work: *mut f64,
        arg1: usize,
        arg2: usize,
        arg3: usize,
    ) -> f64;
    pub fn zlaqp2_(
        m: *mut ::std::os::raw::c_int,
        n: *mut ::std::os::raw::c_int,
        offset: *mut ::std::os::raw::c_int,
        a: *mut Rcomplex,
        lda: *mut ::std::os::raw::c_int,
        jpvt: *mut ::std::os::raw::c_int,
        tau: *mut Rcomplex,
        vn1: *mut f64,
        vn2: *mut f64,
        work: *mut Rcomplex,
    );
    pub fn zlaqps_(
        m: *mut ::std::os::raw::c_int,
        n: *mut ::std::os::raw::c_int,
        offset: *mut ::std::os::raw::c_int,
        nb: *mut *mut ::std::os::raw::c_int,
        kb: *mut ::std::os::raw::c_int,
        a: *mut Rcomplex,
        lda: *mut ::std::os::raw::c_int,
        jpvt: *mut ::std::os::raw::c_int,
        tau: *mut Rcomplex,
        vn1: *mut f64,
        vn2: *mut f64,
        auxv: *mut Rcomplex,
        f: *mut Rcomplex,
        ldf: *mut ::std::os::raw::c_int,
    );
    pub fn zlarf_(
        side: *const ::std::os::raw::c_char,
        m: *mut ::std::os::raw::c_int,
        n: *mut ::std::os::raw::c_int,
        v: *mut Rcomplex,
        incv: *mut ::std::os::raw::c_int,
        tau: *mut Rcomplex,
        c: *mut Rcomplex,
        ldc: *mut ::std::os::raw::c_int,
        work: *mut Rcomplex,
        arg1: usize,
    );
    pub fn zlarfb_(
        side: *const ::std::os::raw::c_char,
        trans: *const ::std::os::raw::c_char,
        direct: *const ::std::os::raw::c_char,
        storev: *const ::std::os::raw::c_char,
        m: *mut ::std::os::raw::c_int,
        n: *mut ::std::os::raw::c_int,
        k: *mut ::std::os::raw::c_int,
        v: *mut Rcomplex,
        ldv: *mut ::std::os::raw::c_int,
        t: *mut Rcomplex,
        ldt: *mut ::std::os::raw::c_int,
        c: *mut Rcomplex,
        ldc: *mut ::std::os::raw::c_int,
        work: *mut Rcomplex,
        ldwork: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
        arg3: usize,
        arg4: usize,
    );
    pub fn zlarfg_(
        n: *mut ::std::os::raw::c_int,
        alpha: *mut Rcomplex,
        x: *mut Rcomplex,
        incx: *mut ::std::os::raw::c_int,
        tau: *mut Rcomplex,
    );
    pub fn zlarft_(
        direct: *const ::std::os::raw::c_char,
        storev: *const ::std::os::raw::c_char,
        n: *mut ::std::os::raw::c_int,
        k: *mut ::std::os::raw::c_int,
        v: *mut Rcomplex,
        ldv: *mut ::std::os::raw::c_int,
        tau: *mut Rcomplex,
        t: *mut Rcomplex,
        ldt: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
    );
    pub fn zlarfx_(
        side: *const ::std::os::raw::c_char,
        m: *mut ::std::os::raw::c_int,
        n: *mut ::std::os::raw::c_int,
        v: *mut Rcomplex,
        tau: *mut Rcomplex,
        c: *mut Rcomplex,
        ldc: *mut ::std::os::raw::c_int,
        work: *mut Rcomplex,
        arg1: usize,
    );
    pub fn zlascl_(
        type_: *const ::std::os::raw::c_char,
        kl: *mut ::std::os::raw::c_int,
        ku: *mut ::std::os::raw::c_int,
        cfrom: *mut f64,
        cto: *mut f64,
        m: *mut ::std::os::raw::c_int,
        n: *mut ::std::os::raw::c_int,
        a: *mut Rcomplex,
        lda: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    pub fn zlaset_(
        uplo: *const ::std::os::raw::c_char,
        m: *mut ::std::os::raw::c_int,
        n: *mut ::std::os::raw::c_int,
        alpha: *mut Rcomplex,
        beta: *mut Rcomplex,
        a: *mut Rcomplex,
        lda: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    pub fn zlasr_(
        side: *const ::std::os::raw::c_char,
        pivot: *const ::std::os::raw::c_char,
        direct: *const ::std::os::raw::c_char,
        m: *mut ::std::os::raw::c_int,
        n: *mut ::std::os::raw::c_int,
        c: *mut f64,
        s: *mut f64,
        a: *mut Rcomplex,
        lda: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
        arg3: usize,
    );
    pub fn zlassq_(
        n: *mut ::std::os::raw::c_int,
        x: *mut Rcomplex,
        incx: *mut ::std::os::raw::c_int,
        scale: *mut f64,
        sumsq: *mut f64,
    );
    pub fn zlaswp_(
        n: *mut ::std::os::raw::c_int,
        a: *mut Rcomplex,
        lda: *mut ::std::os::raw::c_int,
        k1: *mut ::std::os::raw::c_int,
        k2: *mut ::std::os::raw::c_int,
        ipiv: *mut ::std::os::raw::c_int,
        incx: *mut ::std::os::raw::c_int,
    );
    pub fn zlatrd_(
        uplo: *const ::std::os::raw::c_char,
        n: *mut ::std::os::raw::c_int,
        nb: *mut ::std::os::raw::c_int,
        a: *mut Rcomplex,
        lda: *mut ::std::os::raw::c_int,
        e: *mut f64,
        tau: *mut Rcomplex,
        w: *mut Rcomplex,
        ldw: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    pub fn zlatrs_(
        uplo: *const ::std::os::raw::c_char,
        trans: *const ::std::os::raw::c_char,
        diag: *const ::std::os::raw::c_char,
        normin: *const ::std::os::raw::c_char,
        n: *mut ::std::os::raw::c_int,
        a: *mut Rcomplex,
        lda: *mut ::std::os::raw::c_int,
        x: *mut Rcomplex,
        scale: *mut f64,
        cnorm: *mut f64,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
        arg3: usize,
        arg4: usize,
    );
    pub fn zsteqr_(
        compz: *const ::std::os::raw::c_char,
        n: *mut ::std::os::raw::c_int,
        d: *mut f64,
        e: *mut f64,
        z: *mut Rcomplex,
        ldz: *mut ::std::os::raw::c_int,
        work: *mut f64,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    pub fn zpocon_(
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        a: *const Rcomplex,
        lda: *const ::std::os::raw::c_int,
        anorm: *const f64,
        rcond: *mut f64,
        work: *mut Rcomplex,
        rwork: *mut f64,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    pub fn zspcon_(
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        ap: *const Rcomplex,
        ipiv: *const ::std::os::raw::c_int,
        anorm: *const f64,
        rcond: *mut f64,
        work: *mut Rcomplex,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    pub fn zsptrf_(
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        ap: *mut Rcomplex,
        ipiv: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    pub fn zsptri_(
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        ap: *mut Rcomplex,
        ipiv: *mut ::std::os::raw::c_int,
        work: *mut Rcomplex,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    pub fn zsptrs_(
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        nrhs: *const ::std::os::raw::c_int,
        ap: *const Rcomplex,
        ipiv: *const ::std::os::raw::c_int,
        b: *mut Rcomplex,
        ldb: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    pub fn zsycon_(
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        a: *const Rcomplex,
        lda: *const ::std::os::raw::c_int,
        ipiv: *mut ::std::os::raw::c_int,
        anorm: *const f64,
        rcond: *mut f64,
        work: *mut Rcomplex,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    #[doc = "ZSYMV  performs the matrix-vector  operation   y := alpha*A*x + beta*y"]
    pub fn zsymv_(
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        alpha: *const Rcomplex,
        a: *const Rcomplex,
        lda: *const ::std::os::raw::c_int,
        x: *const Rcomplex,
        incx: *const ::std::os::raw::c_int,
        beta: *const Rcomplex,
        y: *mut Rcomplex,
        incy: *const ::std::os::raw::c_int,
        arg1: usize,
    );
    pub fn zsytrf_(
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        a: *mut Rcomplex,
        lda: *const ::std::os::raw::c_int,
        ipiv: *mut ::std::os::raw::c_int,
        work: *mut Rcomplex,
        lwork: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    pub fn zsytri_(
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        a: *mut Rcomplex,
        lda: *const ::std::os::raw::c_int,
        ipiv: *const ::std::os::raw::c_int,
        work: *mut Rcomplex,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    pub fn zsytrs_(
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        nrhs: *const ::std::os::raw::c_int,
        a: *const Rcomplex,
        lda: *const ::std::os::raw::c_int,
        ipiv: *const ::std::os::raw::c_int,
        b: *mut Rcomplex,
        ldb: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    pub fn ztpcon_(
        norm: *const ::std::os::raw::c_char,
        uplo: *const ::std::os::raw::c_char,
        diag: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        ap: *const Rcomplex,
        rcond: *mut f64,
        work: *mut Rcomplex,
        rwork: *mut f64,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
        arg3: usize,
    );
    pub fn ztptri_(
        uplo: *const ::std::os::raw::c_char,
        diag: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        ap: *mut Rcomplex,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
    );
    pub fn ztptrs_(
        uplo: *const ::std::os::raw::c_char,
        trans: *const ::std::os::raw::c_char,
        diag: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        nrhs: *const ::std::os::raw::c_int,
        ap: *const Rcomplex,
        b: *mut Rcomplex,
        ldb: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
        arg3: usize,
    );
    pub fn ztrtri_(
        uplo: *const ::std::os::raw::c_char,
        diag: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        a: *mut Rcomplex,
        lda: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
    );
    #[doc = "ZTRCON estimates the reciprocal of the condition number of a\n triangular matrix A, in either the 1-norm or the infinity-norm."]
    pub fn ztrcon_(
        norm: *const ::std::os::raw::c_char,
        uplo: *const ::std::os::raw::c_char,
        diag: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        a: *const Rcomplex,
        lda: *const ::std::os::raw::c_int,
        rcond: *mut f64,
        work: *mut Rcomplex,
        rwork: *mut f64,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
        arg3: usize,
    );
    pub fn ztrevc_(
        side: *const ::std::os::raw::c_char,
        howmny: *const ::std::os::raw::c_char,
        select: *mut ::std::os::raw::c_int,
        n: *mut ::std::os::raw::c_int,
        t: *mut Rcomplex,
        ldt: *mut ::std::os::raw::c_int,
        vl: *mut Rcomplex,
        ldvl: *mut ::std::os::raw::c_int,
        vr: *mut Rcomplex,
        ldvr: *mut ::std::os::raw::c_int,
        mm: *mut ::std::os::raw::c_int,
        m: *mut *mut ::std::os::raw::c_int,
        work: *mut Rcomplex,
        rwork: *mut f64,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
    );
    pub fn zung2l_(
        m: *mut ::std::os::raw::c_int,
        n: *mut ::std::os::raw::c_int,
        k: *mut ::std::os::raw::c_int,
        a: *mut Rcomplex,
        lda: *mut ::std::os::raw::c_int,
        tau: *mut Rcomplex,
        work: *mut Rcomplex,
        info: *mut ::std::os::raw::c_int,
    );
    pub fn zung2r_(
        m: *mut ::std::os::raw::c_int,
        n: *mut ::std::os::raw::c_int,
        k: *mut ::std::os::raw::c_int,
        a: *mut Rcomplex,
        lda: *mut ::std::os::raw::c_int,
        tau: *mut Rcomplex,
        work: *mut Rcomplex,
        info: *mut ::std::os::raw::c_int,
    );
    pub fn zungbr_(
        vect: *const ::std::os::raw::c_char,
        m: *mut ::std::os::raw::c_int,
        n: *mut ::std::os::raw::c_int,
        k: *mut ::std::os::raw::c_int,
        a: *mut Rcomplex,
        lda: *mut ::std::os::raw::c_int,
        tau: *mut Rcomplex,
        work: *mut Rcomplex,
        lwork: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    pub fn zunghr_(
        n: *mut ::std::os::raw::c_int,
        ilo: *mut ::std::os::raw::c_int,
        ihi: *mut ::std::os::raw::c_int,
        a: *mut Rcomplex,
        lda: *mut ::std::os::raw::c_int,
        tau: *mut Rcomplex,
        work: *mut Rcomplex,
        lwork: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    );
    pub fn zungl2_(
        m: *mut ::std::os::raw::c_int,
        n: *mut ::std::os::raw::c_int,
        k: *mut ::std::os::raw::c_int,
        a: *mut Rcomplex,
        lda: *mut ::std::os::raw::c_int,
        tau: *mut Rcomplex,
        work: *mut Rcomplex,
        info: *mut ::std::os::raw::c_int,
    );
    pub fn zunglq_(
        m: *mut ::std::os::raw::c_int,
        n: *mut ::std::os::raw::c_int,
        k: *mut ::std::os::raw::c_int,
        a: *mut Rcomplex,
        lda: *mut ::std::os::raw::c_int,
        tau: *mut Rcomplex,
        work: *mut Rcomplex,
        lwork: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    );
    pub fn zungql_(
        m: *mut ::std::os::raw::c_int,
        n: *mut ::std::os::raw::c_int,
        k: *mut ::std::os::raw::c_int,
        a: *mut Rcomplex,
        lda: *mut ::std::os::raw::c_int,
        tau: *mut Rcomplex,
        work: *mut Rcomplex,
        lwork: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    );
    pub fn zungqr_(
        m: *mut ::std::os::raw::c_int,
        n: *mut ::std::os::raw::c_int,
        k: *mut ::std::os::raw::c_int,
        a: *mut Rcomplex,
        lda: *mut ::std::os::raw::c_int,
        tau: *mut Rcomplex,
        work: *mut Rcomplex,
        lwork: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    );
    pub fn zungr2_(
        m: *mut ::std::os::raw::c_int,
        n: *mut ::std::os::raw::c_int,
        k: *mut ::std::os::raw::c_int,
        a: *mut Rcomplex,
        lda: *mut ::std::os::raw::c_int,
        tau: *mut Rcomplex,
        work: *mut Rcomplex,
        info: *mut ::std::os::raw::c_int,
    );
    pub fn zungrq_(
        m: *mut ::std::os::raw::c_int,
        n: *mut ::std::os::raw::c_int,
        k: *mut ::std::os::raw::c_int,
        a: *mut Rcomplex,
        lda: *mut ::std::os::raw::c_int,
        tau: *mut Rcomplex,
        work: *mut Rcomplex,
        lwork: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    );
    pub fn zungtr_(
        uplo: *const ::std::os::raw::c_char,
        n: *mut ::std::os::raw::c_int,
        a: *mut Rcomplex,
        lda: *mut ::std::os::raw::c_int,
        tau: *mut Rcomplex,
        work: *mut Rcomplex,
        lwork: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    pub fn zunm2r_(
        side: *const ::std::os::raw::c_char,
        trans: *const ::std::os::raw::c_char,
        m: *mut ::std::os::raw::c_int,
        n: *mut ::std::os::raw::c_int,
        k: *mut ::std::os::raw::c_int,
        a: *mut Rcomplex,
        lda: *mut ::std::os::raw::c_int,
        tau: *mut Rcomplex,
        c: *mut Rcomplex,
        ldc: *mut ::std::os::raw::c_int,
        work: *mut Rcomplex,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
    );
    pub fn zunmbr_(
        vect: *const ::std::os::raw::c_char,
        side: *const ::std::os::raw::c_char,
        trans: *const ::std::os::raw::c_char,
        m: *mut ::std::os::raw::c_int,
        n: *mut ::std::os::raw::c_int,
        k: *mut ::std::os::raw::c_int,
        a: *mut Rcomplex,
        lda: *mut ::std::os::raw::c_int,
        tau: *mut Rcomplex,
        c: *mut Rcomplex,
        ldc: *mut ::std::os::raw::c_int,
        work: *mut Rcomplex,
        lwork: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
        arg3: usize,
    );
    pub fn zunml2_(
        side: *const ::std::os::raw::c_char,
        trans: *const ::std::os::raw::c_char,
        m: *mut ::std::os::raw::c_int,
        n: *mut ::std::os::raw::c_int,
        k: *mut ::std::os::raw::c_int,
        a: *mut Rcomplex,
        lda: *mut ::std::os::raw::c_int,
        tau: *mut Rcomplex,
        c: *mut Rcomplex,
        ldc: *mut ::std::os::raw::c_int,
        work: *mut Rcomplex,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
    );
    pub fn zunmlq_(
        side: *const ::std::os::raw::c_char,
        trans: *const ::std::os::raw::c_char,
        m: *mut ::std::os::raw::c_int,
        n: *mut ::std::os::raw::c_int,
        k: *mut ::std::os::raw::c_int,
        a: *mut Rcomplex,
        lda: *mut ::std::os::raw::c_int,
        tau: *mut Rcomplex,
        c: *mut Rcomplex,
        ldc: *mut ::std::os::raw::c_int,
        work: *mut Rcomplex,
        lwork: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
    );
    #[doc = "Added in R 3.1.0 */\n/* ZGESVD - compute the singular value decomposition (SVD); of a   */\n/* real M-by-N matrix A, optionally computing the left and/or\t   */\n/* right singular vectors"]
    pub fn zgesdd_(
        jobz: *const ::std::os::raw::c_char,
        m: *const ::std::os::raw::c_int,
        n: *const ::std::os::raw::c_int,
        a: *mut Rcomplex,
        lda: *const ::std::os::raw::c_int,
        s: *mut f64,
        u: *mut Rcomplex,
        ldu: *const ::std::os::raw::c_int,
        vt: *mut Rcomplex,
        ldvt: *const ::std::os::raw::c_int,
        work: *mut Rcomplex,
        lwork: *const ::std::os::raw::c_int,
        rwork: *mut f64,
        iwork: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    pub fn zgelsd_(
        m: *mut ::std::os::raw::c_int,
        n: *mut ::std::os::raw::c_int,
        nrhs: *mut ::std::os::raw::c_int,
        a: *mut Rcomplex,
        lda: *mut ::std::os::raw::c_int,
        b: *mut Rcomplex,
        ldb: *mut ::std::os::raw::c_int,
        s: *mut f64,
        rcond: *mut f64,
        rank: *mut ::std::os::raw::c_int,
        work: *mut Rcomplex,
        lwork: *mut ::std::os::raw::c_int,
        rwork: *mut f64,
        iwork: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
    );
    #[doc = "More Complex for R 4.4.0  --- Complex Hermitian (incl \"crossprod\")"]
    pub fn zlanhp_(
        norm: *const ::std::os::raw::c_char,
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        AP: *const Rcomplex,
        work: *mut f64,
        arg1: usize,
        arg2: usize,
    ) -> f64;
    pub fn zhpcon_(
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        AP: *const Rcomplex,
        ipiv: *const ::std::os::raw::c_int,
        anorm: *const f64,
        rcond: *mut f64,
        work: *mut Rcomplex,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    pub fn zhptrf_(
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        AP: *mut Rcomplex,
        ipiv: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    pub fn zhptri_(
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        AP: *mut Rcomplex,
        ipiv: *const ::std::os::raw::c_int,
        work: *mut Rcomplex,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    pub fn zhptrs_(
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        nrhs: *const ::std::os::raw::c_int,
        AP: *const Rcomplex,
        ipiv: *const ::std::os::raw::c_int,
        B: *mut Rcomplex,
        ldb: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    pub fn zhecon_(
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        A: *const Rcomplex,
        lda: *const ::std::os::raw::c_int,
        ipiv: *const ::std::os::raw::c_int,
        anorm: *const f64,
        rcond: *mut f64,
        work: *mut Rcomplex,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    pub fn zhetrf_(
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        A: *mut Rcomplex,
        lda: *const ::std::os::raw::c_int,
        ipiv: *mut ::std::os::raw::c_int,
        work: *mut Rcomplex,
        lwork: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    pub fn zhetri_(
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        A: *mut Rcomplex,
        lda: *const ::std::os::raw::c_int,
        ipiv: *const ::std::os::raw::c_int,
        work: *mut Rcomplex,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    pub fn zhetrs_(
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        nrhs: *const ::std::os::raw::c_int,
        A: *const Rcomplex,
        lda: *const ::std::os::raw::c_int,
        ipiv: *const ::std::os::raw::c_int,
        B: *mut Rcomplex,
        ldb: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
    );
    pub fn zgees_(
        jobvs: *const ::std::os::raw::c_char,
        sort: *const ::std::os::raw::c_char,
        select: ::std::option::Option<
            unsafe extern "C" fn(arg1: *const Rcomplex) -> ::std::os::raw::c_int,
        >,
        n: *const ::std::os::raw::c_int,
        a: *mut Rcomplex,
        lda: *const ::std::os::raw::c_int,
        sdim: *mut ::std::os::raw::c_int,
        w: *mut Rcomplex,
        vs: *mut Rcomplex,
        ldvs: *const ::std::os::raw::c_int,
        work: *mut Rcomplex,
        lwork: *const ::std::os::raw::c_int,
        rwork: *mut f64,
        bwork: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
    );
    pub fn zhpev_(
        jobz: *const ::std::os::raw::c_char,
        uplo: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        ap: *mut Rcomplex,
        w: *mut f64,
        z: *mut Rcomplex,
        ldz: *const ::std::os::raw::c_int,
        work: *mut Rcomplex,
        rwork: *mut f64,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
    );
    #[doc = "DGEGV - compute for a pair of n-by-n real nonsymmetric */\n/* matrices A and B, the generalized eigenvalues (alphar +/- */\n/* alphai*i, beta);, and optionally, the left and/or right */\n/* generalized eigenvectors (VL and VR);"]
    pub fn dgegv_(
        jobvl: *const ::std::os::raw::c_char,
        jobvr: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_int,
        a: *mut f64,
        lda: *const ::std::os::raw::c_int,
        b: *mut f64,
        ldb: *const ::std::os::raw::c_int,
        alphar: *mut f64,
        alphai: *mut f64,
        beta: *const f64,
        vl: *mut f64,
        ldvl: *const ::std::os::raw::c_int,
        vr: *mut f64,
        ldvr: *const ::std::os::raw::c_int,
        work: *mut f64,
        lwork: *const ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
    );
    #[doc = "DGEQPF - compute a QR factorization with column pivoting of a */\n/* real M-by-N matrix A"]
    pub fn dgeqpf_(
        m: *const ::std::os::raw::c_int,
        n: *const ::std::os::raw::c_int,
        a: *mut f64,
        lda: *const ::std::os::raw::c_int,
        jpvt: *mut ::std::os::raw::c_int,
        tau: *mut f64,
        work: *mut f64,
        info: *mut ::std::os::raw::c_int,
    );
    #[doc = "DGGSVD - compute the generalized singular value decomposition */\n/* (GSVD) of an M-by-N real matrix A and P-by-N real matrix B"]
    pub fn dggsvd_(
        jobu: *const ::std::os::raw::c_char,
        jobv: *const ::std::os::raw::c_char,
        jobq: *const ::std::os::raw::c_char,
        m: *const ::std::os::raw::c_int,
        n: *const ::std::os::raw::c_int,
        p: *const ::std::os::raw::c_int,
        k: *const ::std::os::raw::c_int,
        l: *const ::std::os::raw::c_int,
        a: *mut f64,
        lda: *const ::std::os::raw::c_int,
        b: *mut f64,
        ldb: *const ::std::os::raw::c_int,
        alpha: *const f64,
        beta: *const f64,
        u: *mut f64,
        ldu: *const ::std::os::raw::c_int,
        v: *mut f64,
        ldv: *const ::std::os::raw::c_int,
        q: *mut f64,
        ldq: *const ::std::os::raw::c_int,
        work: *mut f64,
        iwork: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
        arg3: usize,
    );
    #[doc = "DTZRQF - reduce the M-by-N ( M<=N ); real upper trapezoidal */\n/* matrix A to upper triangular form by means of orthogonal */\n/* transformations"]
    pub fn dtzrqf_(
        m: *const ::std::os::raw::c_int,
        n: *const ::std::os::raw::c_int,
        a: *mut f64,
        lda: *const ::std::os::raw::c_int,
        tau: *mut f64,
        info: *mut ::std::os::raw::c_int,
    );
    #[doc = "DLAHRD - reduce the first NB columns of a real general */\n/* n-by-(n-k+1); matrix A so that elements below the k-th */\n/* subdiagonal are zero"]
    pub fn dlahrd_(
        n: *const ::std::os::raw::c_int,
        k: *const ::std::os::raw::c_int,
        nb: *const ::std::os::raw::c_int,
        a: *mut f64,
        lda: *const ::std::os::raw::c_int,
        tau: *mut f64,
        t: *mut f64,
        ldt: *const ::std::os::raw::c_int,
        y: *mut f64,
        ldy: *const ::std::os::raw::c_int,
    );
    #[doc = "DLATZM - apply a Householder matrix generated by DTZRQF to a */\n/* matrix"]
    pub fn dlatzm_(
        side: *const ::std::os::raw::c_char,
        m: *const ::std::os::raw::c_int,
        n: *const ::std::os::raw::c_int,
        v: *const f64,
        incv: *const ::std::os::raw::c_int,
        tau: *const f64,
        c1: *mut f64,
        c2: *mut f64,
        ldc: *const ::std::os::raw::c_int,
        work: *mut f64,
        arg1: usize,
    );
    pub fn dgegs_(
        jobvsl: *const ::std::os::raw::c_char,
        jobvsr: *const ::std::os::raw::c_char,
        n: *mut ::std::os::raw::c_int,
        a: *mut f64,
        lda: *mut ::std::os::raw::c_int,
        b: *mut f64,
        ldb: *mut ::std::os::raw::c_int,
        alphar: *mut f64,
        alphai: *mut f64,
        beta: *mut f64,
        vsl: *mut f64,
        ldvsl: *mut ::std::os::raw::c_int,
        vsr: *mut f64,
        ldvsr: *mut ::std::os::raw::c_int,
        work: *mut f64,
        lwork: *mut ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
    );
    pub fn dgelsx_(
        m: *mut ::std::os::raw::c_int,
        n: *mut ::std::os::raw::c_int,
        nrhs: *mut ::std::os::raw::c_int,
        a: *mut f64,
        lda: *mut ::std::os::raw::c_int,
        b: *mut f64,
        ldb: *mut ::std::os::raw::c_int,
        jpvt: *mut ::std::os::raw::c_int,
        rcond: *mut f64,
        rank: *mut ::std::os::raw::c_int,
        work: *mut f64,
        info: *mut ::std::os::raw::c_int,
    );
    pub fn dggsvp_(
        jobu: *const ::std::os::raw::c_char,
        jobv: *const ::std::os::raw::c_char,
        jobq: *const ::std::os::raw::c_char,
        m: *mut ::std::os::raw::c_int,
        p: *mut ::std::os::raw::c_int,
        n: *mut ::std::os::raw::c_int,
        a: *mut f64,
        lda: *mut ::std::os::raw::c_int,
        b: *mut f64,
        ldb: *mut ::std::os::raw::c_int,
        tola: *mut f64,
        tolb: *mut f64,
        k: *mut ::std::os::raw::c_int,
        l: *mut *mut ::std::os::raw::c_int,
        u: *mut f64,
        ldu: *mut ::std::os::raw::c_int,
        v: *mut f64,
        ldv: *mut ::std::os::raw::c_int,
        q: *mut f64,
        ldq: *mut ::std::os::raw::c_int,
        iwork: *mut ::std::os::raw::c_int,
        tau: *mut f64,
        work: *mut f64,
        info: *mut ::std::os::raw::c_int,
        arg1: usize,
        arg2: usize,
        arg3: usize,
    );
    pub fn zlahrd_(
        n: *mut ::std::os::raw::c_int,
        k: *mut ::std::os::raw::c_int,
        nb: *mut ::std::os::raw::c_int,
        a: *mut Rcomplex,
        lda: *mut ::std::os::raw::c_int,
        tau: *mut Rcomplex,
        t: *mut Rcomplex,
        ldt: *mut ::std::os::raw::c_int,
        y: *mut Rcomplex,
        ldy: *mut ::std::os::raw::c_int,
    );
}
